/// Sheriff — Goblin SSG + Wiki (v0.5, uses md_to_html builtin)

/// ------------------------------
/// Front-matter split
/// ------------------------------
/// Split optional YAML front-matter fenced by lines of exactly '---'.
/// Returns (meta_text, body_text). If no fences, meta_text="", body_text=original.
act split_frontmatter(markdown_text)
    fm_lines = lines(markdown_text)

    if fm_lines.len == 0
        return "", markdown_text
    end

    if fm_lines[0].trim !== "---"
        return "", markdown_text
    end

    fence_close_index = nil
    scan_index = 1
    while scan_index < fm_lines.len
        if fm_lines[scan_index].trim == "---"
            fence_close_index = scan_index
            scan_index = fm_lines.len      /// break the loop without 'stop'
            skip
        end
        scan_index = scan_index + 1
    end

    if fence_close_index == nil
        /// no closing fence found; treat as no front-matter
        return "", markdown_text
    end

    meta_lines = fm_lines[1:fence_close_index]
    body_lines = fm_lines[fence_close_index + 1:fm_lines.len]

    return join(meta_lines, "\n").trim, join(body_lines, "\n").trim
end

/// ------------------------------
/// HTML escaping (for <title>, etc.)
/// ------------------------------
act escape_html(input_text)
    out_text = input_text
    update_where!(out_text, "&", "&amp;")
    update_where!(out_text, "<", "&lt;")
    update_where!(out_text, ">", "&gt;")
    update_where!(out_text, "\"", "&quot;")
    update_where!(out_text, "'", "&#39;")
    return out_text
end

/// ------------------------------
/// Title extraction (front-matter title → first ATX header → fallback)
/// ------------------------------
act extract_title(fm_map, body_text)
    if fm_map !== nil
        if fm_map["title"] !== nil
            title_candidate = fm_map["title"]
            if title_candidate.trim !== ""
                return title_candidate.trim
            end
        end
    end

    normalized = body_text
    update_where!(normalized, "\r\n", "\n")
    update_where!(normalized, "\r", "\n")
    lines_arr = lines(normalized)

    scan_index = 0
    while scan_index < lines_arr.len
        ln = lines_arr[scan_index].trim_lead
        if ln !== ""
            toks = split(ln, " ")
            tok0 = ""
            if toks.len > 0
                tok0 = toks[0]
            end
            if (tok0 == "#" or tok0 == "##" or tok0 == "###") and toks.len > 1
                txt = ""
                ti = 1
                while ti < toks.len
                    if txt == ""
                        txt = toks[ti]
                    else
                        txt = txt ++ toks[ti]
                    end
                    ti = ti + 1
                end
                return txt.trim
            end
        end
        scan_index = scan_index + 1
    end

    return "Untitled"
end

/// ------------------------------
/// Path helpers (string-based)
/// ------------------------------
act path_dirname(path_text)
    p = path_text
    slash_positions = find_all(p, "/")
    if slash_positions.len == 0
        return ""
    end
    last_idx = slash_positions[slash_positions.len - 1]
    if last_idx == 0
        return ""
    end
    return p[0:last_idx]
end

act path_basename(path_text)
    p = path_text
    slash_positions = find_all(p, "/")
    if slash_positions.len == 0
        return p
    end
    last_idx = slash_positions[slash_positions.len - 1]
    return p[last_idx + 1:p.len]
end

/// Ensure a directory tree exists (split on '/'; create each segment)
act ensure_dir_tree(dir_path)
    say "[dbg] ensure_dir_tree: " ++ dir_path
    if dir_path == "" or dir_path == nil
        skip
    end
    parts = split(dir_path, "/")
    acc_dir = ""
    idx = 0
    while idx < parts.len
        part = parts[idx].trim
        if part !== ""
            if acc_dir === ""
                acc_dir = part
            else
                acc_dir = path_join(acc_dir, part)
            end
            say "[dbg] mkdir: " ++ acc_dir
            create_dir!(acc_dir)
        end
        idx = idx + 1
    end
end

/// ------------------------------
/// UUID sidecars under .sheriff/ids/…  (stable per content path)
/// ------------------------------
act read_or_create_uuid_for(rel_content_path)
    ids_root_dir = ".sheriff/ids"
    after_content = rel_content_path["content/".len:rel_content_path.len]   /// drop "content/" prefix
    sidecar_rel   = path_join(ids_root_dir, after_content) + ".id"

    sidecar_dir = path_dirname(sidecar_rel)
    ensure_dir_tree(sidecar_dir)

    if file_exists(sidecar_rel)
        existing = read_text(sidecar_rel).trim
        if existing !== ""
            return existing
        end
    end

    new_id_value = uuid_v7()
    write_text!(sidecar_rel, new_id_value)
    return new_id_value
end

/// ------------------------------
/// Output paths/href under dist/, preserving subdirs under content/
/// ------------------------------
act compute_output_paths(rel_content_path, final_slug)
    content_prefix_len = "content/".len
    after_content = rel_content_path[content_prefix_len:rel_content_path.len]
    dir_part = path_dirname(after_content)

    out_dir = "dist"
    if dir_part !== ""
        out_dir = path_join(out_dir, dir_part)
    end

    out_file = path_join(out_dir, final_slug + ".html")

    href = "/"
    if dir_part !== ""
        href = href + dir_part + "/"
    end
    href = href + final_slug + ".html"

    return { "out_dir": out_dir, "out_file": out_file, "href": href }
end

/// ------------------------------
/// Enumerate markdown files under content/
/// ------------------------------
act list_markdown_files()
    all = walk("content", "**/*.md")
    only_content = []
    i = 0
    while i < all.len
        p = all[i]
        if has(p, "content/") and find(p, "content/") == 0
            put_last!(only_content, p)     /// append one path
        end
        i = i + 1
    end
    return only_content
end

/// ------------------------------
/// Build a single page and return its manifest record (Map)
/// ------------------------------
act build_single_page(rel_content_path)
    say "[dbg] page: read " ++ rel_content_path
    src_text = read_text(rel_content_path)

    fm_text, body_text = split_frontmatter(src_text)
    say "[dbg] page: split_frontmatter len(fm)= " ++ ("" + fm_text.len) ++ "  len(body)= " ++ ("" + body_text.len)

    fm_map = nil
    if fm_text !== ""
        fm_map = yaml_parse(fm_text)
        say "[dbg] page: yaml count " ++ ("" + count(fm_map))
    end

    title_guess = extract_title(fm_map, body_text)
    say "[dbg] page: title= " ++ title_guess

    base_name = path_basename(rel_content_path)
    name_no_ext = base_name
    dot_pos = find(base_name, ".md")
    if dot_pos !== nil
        name_no_ext = base_name[0:dot_pos]
    end

    final_slug = ""
    if fm_map !== nil and fm_map["slug"] !== nil and fm_map["slug"].trim !== ""
        final_slug = fm_map["slug"].trim
    else
        if title_guess !== "Untitled"
            final_slug = slug(title_guess)
        else
            final_slug = slug(name_no_ext)
        end
    end
    if final_slug === "" or final_slug === nil
        final_slug = "index"
    end
    say "[dbg] page: slug= " ++ final_slug

    page_uuid = read_or_create_uuid_for(rel_content_path)
    say "[dbg] page: uuid= " ++ page_uuid

    /// Render Markdown → HTML via builtin (from interpreter)
    say "[dbg] page: BEFORE render"
    html_body = md_to_html(body_text)
    say "[dbg] page: AFTER  render"

    /// Build output paths
    say "[dbg] page: BEFORE paths"
    paths = compute_output_paths(rel_content_path, final_slug)
    say "[dbg] page: AFTER  paths (dir=" ++ paths["out_dir"] ++ ", file=" ++ paths["out_file"] ++ ")"

    /// Ensure out dir
    say "[dbg] page: BEFORE ensure out_dir"
    ensure_dir_tree(paths["out_dir"])
    say "[dbg] page: AFTER  ensure out_dir"

    /// Build final HTML document (small, plain layout)
    say "[dbg] page: BEFORE html build (join)"
    html_pieces = [
        "<!doctype html>\n",
        "<html lang=\"en\">\n",
        "<head>\n",
        "  <meta charset=\"utf-8\"/>\n",
        "  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>\n",
        "  <title>",  escape_html(title_guess), "</title>\n",
        "  <link rel=\"stylesheet\" href=\"/style.css\"/>\n",
        "</head>\n",
        "<body>\n",
        "<main>\n",
        html_body,
        "\n</main>\n",
        "</body>\n",
        "</html>\n"
    ]
    html_document = join(html_pieces, "")
    say "[dbg] page: AFTER  html build (join)"

    say "[dbg] page: BEFORE write"
    write_text!(paths["out_file"], html_document)
    say "[dbg] page: AFTER  write"

    return {
        "uuid":  page_uuid,
        "rel":   rel_content_path["content/".len:rel_content_path.len],
        "slug":  final_slug,
        "title": title_guess,
        "href":  paths["href"],
        "links_to": [],
        "missing":  []
    }
end

/// ------------------------------
/// Build entire site: all pages, public assets, manifest
/// ------------------------------
act build_site()
    say "[dbg] build_site: start"
    create_dir!("dist")

    records = []
    md_files = list_markdown_files()
    say "[dbg] build_site: files " ++ ("" + md_files.len)

    file_index = 0
    while file_index < md_files.len
        current_rel = md_files[file_index]
        say "[dbg] build_site: -> build " ++ current_rel

        record_map = build_single_page(current_rel)

        say "[dbg] build_site: <- built " ++ current_rel
        put_last!(records, record_map)

        file_index = file_index + 1
    end

    /// Copy public/** → dist/**
    if file_exists("public")
        say "[dbg] assets: scan public"
        public_files = walk("public", "**/*")
        pf_i = 0
        while pf_i < public_files.len
            src_path = public_files[pf_i]

            prefix = "public/"
            rel_path = src_path
            if has(src_path, prefix) and find(src_path, prefix) == 0
                rel_path = src_path[prefix.len:src_path.len]
            end

            dst_path = path_join("dist", rel_path)
            dst_dir  = path_dirname(dst_path)
            ensure_dir_tree(dst_dir)

            say "[dbg] assets: copy " ++ src_path ++ " -> " ++ dst_path
            copy_file!(src_path, dst_path)

            pf_i = pf_i + 1
        end
    end

    manifest_obj = { "pages": records }
    write_json!("dist/manifest.json", manifest_obj)

    say "BUILD: wrote " ++ ("" + records.len) ++ " page(s)"
end

/// ------------------------------
/// CLI
/// ------------------------------
act help
    say "sheriff:" ++ "build | serve | help"
end

act build
    build_site()
end

act serve
    say "SERVE (stub)"
end

/// one-shot CLI dispatch
cli_command = ""
cli_ran = false

if args !== nil and args.len > 0
    cli_command = args[0].lower.trim
    judge using cli_command
        == "build":
            build()
            cli_ran = true
        == "serve":
            serve()
            cli_ran = true
        == "help":
            help()
            cli_ran = true
        else:
            say "unknown command:" ++ cli_command
            cli_ran = true
    end
end

if cli_ran == false
    help()
end