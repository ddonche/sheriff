/// Sheriff — Complete solution with frontmatter handling and proper file extension conversion
import modules/scout/scout    as scout
import modules/scout/toc as toc
import modules/brindle/brindle as br
import modules/badge/badge as badge

scout::publish_tokens()
br::build_css_files()
br::publish_tokens()
badge::publish_tokens()

/// Get just the frontmatter text (inner YAML only, no fences)
act get_frontmatter(content)
    /// Accept leading blanks, require fence at BOL, allow EOF-close, EXCLUDE delims
    opts = {
        "include_delims": false,
        "allow_eof_close": true,
        "leading_blanks_ok": true,
        "require_bol": true
    }
    fm = keep_between(content, "---\n", "\n---\n", opts)
    if fm == ""
        fm = keep_between(content, "---\n", "\n---", opts)
    end
    return fm.trim
end

/// Get body text by removing frontmatter (non-mutating, uses IGNORE)
act extract_body_content(content)
    opts = {
        "include_delims": true,
        "allow_eof_close": true,
        "leading_blanks_ok": true,
        "require_bol": true
    }
    body = ignore_between(content, "---\n", "\n---\n", opts)
    if body == content
        /// no primary match; try EOF-close
        body = ignore_between(content, "---\n", "\n---", opts)
    end
    return body
end

/// Extract the 'title:' line from frontmatter text (kept for future use)
act extract_title(frontmatter_text)
    if frontmatter_text == nil or frontmatter_text == ""
        return ""
    end

    fm_lines = lines(frontmatter_text)
    for line_text in fm_lines
        lowered = lower(line_text)
        if starts_with(lowered, "title:")
            raw_after = after(line_text, "title:")
            /// remove at most one leading space or tab after the colon
            cleaned = raw_after
            if cleaned.len >= 1 and (cleaned[0:1] == " " or cleaned[0:1] == "\t")
                cleaned = cleaned[1:cleaned.len]
            end
            if cleaned !== ""
                return cleaned
            end
        end
    end

    return ""
end

/// Return the first ATX H1 ("# Title") from the body (kept for future use)
act h1_from_body(body_text)
    for line_text in lines(body_text)
        trimmed = line_text.trim
        if trimmed.len >= 2 and trimmed[0:1] == "#" and trimmed[1:2] !== "#"
            return after(trimmed, "#").trim
        end
    end
    return ""
end

act create_all_dirs(path)
    /// Ensure all directories in the path exist
    slash_positions = find_all(path, "/")

    for slash_pos in slash_positions
        dir_part = path[0:slash_pos]
        if dir_part !== "" and file_exists(dir_part) == false
            create_dir!(dir_part)
        end
    end
end

/// Mirror entire /public tree into /dist/public (binary-safe via copy_file!)
act mirror_public_tree()
    if file_exists("public") == false
        return 0
    end

    create_dir!("dist/public")

    copied = 0
    for src in walk("public", "**/*.*")
        norm_src = src
        update_where!(norm_src, "\\", "/")

        rel = norm_src["public/".len:norm_src.len]
        if rel === ""
            skip
        end

        dest = "dist/public/" + rel

        slash_positions = find_all(dest, "/")
        for pos in slash_positions
            dir_path = dest[0:pos]
            if dir_path !== "" and file_exists(dir_path) == false
                create_dir!(dir_path)
            end
        end

        copy_file!(norm_src, dest)
        copied = copied + 1
    end
    return copied
end

/// Sheriff build: read → clean → split → parse fm → render body only (manual HTML)
act build_site()
    say "Starting build process"

    create_dir!("dist")
    public_count = mirror_public_tree()
    say "Public files mirrored: " + string(public_count)

    say "Finding markdown files"
    md_files = walk("content", "**/*.md")
    say "Found " + string(md_files.len) + " files"

    for file_path in md_files
        say "Processing: " + file_path

        content_path = file_path["content/".len:file_path.len]
        md_suffix_position = content_path.len - 3

        if md_suffix_position <= 0
            say "Invalid file path: " + file_path
            skip
        end

        content_stem = content_path[0:md_suffix_position]
        output_path = "dist/" + content_stem + ".html"
        say "Output path: " + output_path

        create_all_dirs(output_path)

        raw     = read_text(file_path)
        clean   = sanitize_bom(raw)
        content = normalize_newlines(clean)

        frontmatter  = get_frontmatter(content)
        body_content = extract_body_content(content)

        normalized_out = output_path
        update_where!(normalized_out, "\\", "/")

        path_parts = split(normalized_out, "/")
        out_file   = path_parts[path_parts.len - 1]

        base_no_ext       = ignore_where(out_file, ".html")
        underscore_parts  = split(base_no_ext, "_")
        spaced_title      = join(underscore_parts, " ")
        page_title        = title(spaced_title)

        html_body = md_to_html(body_content)

        /// ---- breadcrumbs and TOC (skip home) --------------------------------------------
        page_stem = stem(output_path)
        say "DEBUG: output_path = " + output_path
        say "DEBUG: page_stem = " + page_stem

        /// ALWAYS reset TOC for this page
        toc::clear_toc()

        if page_stem !== "index"
            say "DEBUG: Calling breadcrumbs for " + output_path
            scout::breadcrumbs(output_path, "Home")  /// Just call — it registers token
            toc::process_toc(html_body)
            say "DEBUG: BREADCRUMBS token registered"
        else
            say "DEBUG: Skipping breadcrumbs (index page)"
            scout::breadcrumbs(output_path, "Home")  /// Still call — registers empty
        end
        /// -------------------------------------------------------------------------

        root_prefix = ""
        slash_positions = find_all(content_stem, "/")
        for pos in slash_positions
            root_prefix = root_prefix + "../"
        end

        html_content = """
        <!doctype html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <link rel="icon" href="{{{BRINDLE::FAVICON}}}">
            <title>{page_title}</title>
            {{{BRINDLE::CSS}}}
            {{{BRINDLE::HIGHLIGHT_HEAD}}}
        </head>
        <body>
            <header class="site-header">
                <div class="container header-inner">
                    <a class="brand" href="/index.html">
                        <img class="brand-logo" src="{{{BRINDLE::LOGO_SRC}}}" alt="{{{BRINDLE::BRAND_NAME}}}" />
                        <span class="brand-name">{{{BRINDLE::BRAND_NAME}}}</span>
                        {{{BADGE::VERSION}}}
                    </a>

                    <nav id="site-nav" class="nav">
                        {{{SCOUT::DOCS}}}
                    </nav>

                    {{{BRINDLE::THEME_TOGGLE}}}

                    <form class="site-search" role="search" action="#" method="get">
                        <input
                            type="search"
                            name="q"
                            placeholder="Search..."
                            aria-label="Search docs"
                        />
                    </form>
                </div>
            </header>

            <main class="container">
                {{{SCOUT::BREADCRUMBS}}}

                <div class="content-grid">
                    {{{SCOUT::TOC}}}
                    <div class="doc-body">
                        {html_body}
                    </div>
                </div>
            </main>

            <footer id="site-footer">
                <div class="container">
                    {{{SCOUT::FOOTER}}}
                </div>
            </footer>
                {{{BRINDLE::HIGHLIGHT_FOOT}}}
                {{{BRINDLE::THEME_SCRIPT}}}
        </body>
        </html>
        """
        write_text!(output_path, html_content)
    end

    say "Build completed successfully!"
end

/// CLI entry point — original one-liner
if args !== nil and args.len > 0 and args[0].lower.trim == "build"
    build_site()
else
    say "Usage: goblin run main.gbln build"
end