<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Untitled</title>

  <!-- Base styles (user can swap CDN or self-host later) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2.0.6/css/pico.min.css" />
  <!-- Optional local overrides -->
  <link rel="stylesheet" href="/style.css" />

  
</head>
<body>
  <header class="container">
    <!-- top navbar generated from ssg.nav -->
    <nav class="container-fluid"><ul role="list"><li><a class="contrast" href="/index.html"><strong>Site</strong></a></li></ul><ul role="list"><li><a href="/index-html">Home</a></li><li><details><summary>Docs</summary><ul role="list"><li><a href="/index-html">Overview</a></li><li><details><summary>Getting Started</summary><ul role="list"><li><a href="/index-html">Introduction</a></li><li><a href="/installation-html">Installation</a></li><li><a href="/basics-html">Basics</a></li></ul></details></li></ul></details></li><li><a href="/blog-html">Blog</a></li><li><a href="/changelog-html">Changelog</a></li></ul></nav>
  </header>

  <div class="container">
    <div class="grid">
      <aside>
        <!-- optional sidebar for active section; empty if none -->
        
      </aside>
      <main>
        <h1><strong>Goblin Decision Constructs — Canonical Spec (v1)</strong></h1>
<p><em>(Exclusive &amp; Inclusive Decision Logic)</em></p>
<hr />
<h2>1) Overview</h2>
<p><code>judge</code> and <code>judge_all</code> express decision tables directly in code.</p>
<ul>
<li><strong><code>judge</code></strong>: <em>exclusive</em> — first matching arm wins.</li>
<li><strong><code>judge_all</code></strong>: <em>inclusive</em> — all matching arms that evaluate truthy run (in source order) and, in expr-form, their results are collected.</li>
</ul>
<p>This spec reflects the current implementation <strong>plus</strong> clearly marked planned extensions (kept compatible with your blog post semantics, including <strong>weights</strong>).</p>
<hr />
<h2>2) Core Syntax</h2>
<h3>2.1 <code>judge</code> — Exclusive</h3>
<pre lang="goblin"><code>score = 95

grade =
    judge
        score &gt;= 90: &quot;A&quot;
        score &gt;= 80: &quot;B&quot;
        score &gt;= 70: &quot;C&quot;
        else:         &quot;F&quot;
    end
</code></pre>
<ul>
<li>Evaluates top-to-bottom, stops on first truthy condition.</li>
</ul>
<h3>2.2 <code>judge_all</code> — Inclusive</h3>
<pre lang="goblin"><code>balance = 45
trial_days = 5
has_new_features = true
maintenance_scheduled = false

notifications =
    judge_all
        balance &lt; 50:          &quot;Low balance warning&quot;
        trial_days &lt; 7:        &quot;Trial expiring soon&quot;
        has_new_features:      &quot;Check out new tools&quot;
        maintenance_scheduled: &quot;Maintenance tonight&quot;
        else:                  &quot;All systems normal&quot;
    end

say notifications
</code></pre>
<ul>
<li>All truthy arms run; expression-form returns an array of results in arm order.</li>
</ul>
<hr />
<h2>3) Subject Shorthand: <code>judge using &lt;expr&gt;</code></h2>
<p>Avoid repeating the same subject on every arm.</p>
<pre lang="goblin"><code>score = 95

judge using score
    &gt;= 90: say &quot;A&quot;
    &gt;= 80: say &quot;B&quot;
    &gt;= 70: say &quot;C&quot;
    else:  say &quot;F&quot;
end
</code></pre>
<p>Also works with <code>judge_all</code>:</p>
<pre lang="goblin"><code>x = -3

judge_all using x
    &gt; 0:  say &quot;positive&quot;
    &lt; 0:  say &quot;negative&quot;
    else: say &quot;zero&quot;
end
</code></pre>
<hr />
<h2>4) Enum Matching with <code>using</code></h2>
<p>Enums in Goblin can be matched by name using <code>using &lt;EnumName&gt;</code>.</p>
<pre lang="goblin"><code>/// Enum definition and matching tests
enum Status
    idle
    loading
    ready
    error
end

enum Priority
    low
    medium
    high
    critical
end

say &quot;=== testing judge with enum ===&quot;
status = Status::idle
judge status using Status
    idle:    say &quot;System is idle&quot;
    loading: say &quot;Processing...&quot;
    ready:   say &quot;Ready to proceed&quot;
    error:   say &quot;Error occurred&quot;
end

priority = Priority::high
judge priority using Priority
    low:      say &quot;Low priority&quot;
    medium:   say &quot;Medium priority&quot;
    high:     say &quot;High priority alert&quot;
    critical: say &quot;CRITICAL - Immediate action required&quot;
end
</code></pre>
<p><em>(Future: tagged-union payload destructuring &amp; guards — planned, see §12.4.)</em></p>
<hr />
<h2>5) Arm Bodies: Expression, Statement, or Block</h2>
<pre lang="goblin"><code>x = 42
hit = &quot;none&quot;

judge
    x &gt; 100: hit = &quot;gt100&quot;         /// inline statement
    x &gt; 40:  &quot;compile-only-expr&quot;    /// inline expression (no side effect)
    x &gt; 0:
        say &quot;block ok&quot;              /// block
        hit = &quot;gt0&quot;
    else:
        hit = &quot;else&quot;
end
</code></pre>
<ul>
<li>Inline <strong>expression</strong> result is used only in expr-form.</li>
<li>Inline <strong>statement</strong> executes immediately.</li>
<li><strong>Block</strong> runs all contained statements.</li>
</ul>
<p>Control flow (<code>return</code>, <code>break</code>, <code>continue</code>) propagates as expected; in <code>judge_all</code>, a <code>return</code> short-circuits remaining arms.</p>
<hr />
<h2>6) Header Return: <code>judge return &lt;expr&gt;</code></h2>
<p>A shared return value for <strong>empty</strong> matching arms.</p>
<pre lang="goblin"><code>judge return &quot;ERR&quot;
    a &lt; 0:
    b &lt; 0:
    c &lt; 0:
end
</code></pre>
<p>Equivalent to inlining <code>return &quot;ERR&quot;</code> in each empty arm. Works with both <code>judge</code> and <code>judge_all</code>.</p>
<p><em>(Header <strong>do</strong> default for non-return actions is planned; see §11.)</em></p>
<hr />
<h2>7) Evaluation Semantics</h2>
<table>
<thead>
<tr>
<th>Construct</th>
<th>Matching Policy</th>
<th>Execution</th>
<th>Expression Result</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>judge</code></td>
<td>First truthy arm wins</td>
<td>Stops after first match</td>
<td>Value of arm (or <code>nil</code>)</td>
</tr>
<tr>
<td><code>judge_all</code></td>
<td>All truthy arms</td>
<td>Runs all in source order</td>
<td>Array of arm results</td>
</tr>
</tbody>
</table>
<ul>
<li>Truthiness uses standard Goblin rules (<code>false</code>/<code>nil</code> falsey; everything else truthy).</li>
<li><code>else</code> matches when no prior arm matched.</li>
</ul>
<hr />
<h2>8) Rich Condition Syntax (as in Goblin expressions)</h2>
<ul>
<li>
<p>Logical ops: <code>and</code>, <code>or</code>, <code>not</code> (with <code>()</code> precedence) — <strong>reuse normal expression grammar</strong>.</p>
</li>
<li>
<p>Chaining sugar <code>&lt;&gt;</code> works the same within judge conditions.</p>
</li>
<li>
<p>Ranges / filters if supported elsewhere:</p>
<pre lang="goblin"><code>shipping_cost =
    judge
        weight between 0..1:   $5.00
        weight between 1..5:   $8.00
        weight between 5..20:  $12.00
        else:                  $25.00
    end
</code></pre>
</li>
<li>
<p><code>where</code>/field-DLS examples align with existing Goblin semantics.</p>
</li>
<li>
<p>Field access operator <code>&gt;&gt;</code> used exactly as outside judge:</p>
<pre lang="goblin"><code>user_status =
    judge
        user &gt;&gt; &quot;is_premium&quot;:     &quot;premium&quot;
        user &gt;&gt; &quot;trial_expired&quot;:  &quot;expired&quot;
        user &gt;&gt; &quot;score&quot; &lt; 50:     &quot;basic&quot;
        else:                      &quot;standard&quot;
    end
</code></pre>
</li>
</ul>
<hr />
<h2>9) Method-Chaining with Judge</h2>
<p>Judge meshes with fluent chains for business rules:</p>
<pre lang="goblin"><code>order =
    judge
        fraud_check(order):           order.hold.send_alert
        order &gt;&gt; &quot;priority&quot; &gt;= 9:     order.expedite.notify_team
        payment_failed(order):        order.retry_payment.log_attempt
        inventory_check(order):       order.fulfill.notify_customer
        else:                         order.schedule_standard
    end
</code></pre>
<p>Nested decisions remain readable:</p>
<pre lang="goblin"><code>result =
    judge
        user &gt;&gt; is_premium: data.enrich.prioritize.cache
        user &gt;&gt; is_trial:   data.basic_clean.rate_limit
        user &gt;&gt; score &lt; 50:
            judge
                data.size &gt; 1000: data.throttle
                else:             data.process_normally
            end
        else:               data.standard_process
    end
</code></pre>
<hr />
<h2>10) Weighted <code>judge_all</code> — <strong>Planned (kept from blog post)</strong></h2>
<p>Weights prioritize inclusive actions (e.g., async engines/processors). Syntax per blog post:</p>
<pre lang="goblin"><code>actions =
    judge_all
        [10] balance &gt;&gt; amount &lt; $10:     fraud_alert(transaction)
        [5]  user &gt;&gt; new_signup:          welcome_email(user)
        [1]  analytics &gt;&gt; needed:         log_event(transaction)
        else:                             standard_processing
    end
</code></pre>
<ul>
<li>Sort by descending weight; equal weights keep source order.</li>
<li>Encourages priority <em>tiers</em> (e.g., <code>[10]</code> security, <code>[5]</code> UX setup, <code>[1]</code> analytics).</li>
<li>Runtime integration: immediate/next-tick/deferred scheduling is an engine concern, not syntax.</li>
</ul>
<p>Another real-world example (stacking status effects):</p>
<pre lang="goblin"><code>status_changes =
    judge_all
        [10] spell_cast &gt;&gt; type == &quot;fire&quot; and environment &gt;&gt; is_cold: player.warm_up.boost_fire_damage
        [7]  potion_used &gt;&gt; type == &quot;strength&quot;:                       player.double_strength.show_muscles
        [3]  area &gt;&gt; has_magic_field:                                   player.regenerate_mana.glow
        [1]  time &gt;&gt; is_night and player &gt;&gt; class == &quot;vampire&quot;:       player.night_vision.bonus_stealth
        else: &quot;No special effects&quot;
    end
</code></pre>
<blockquote>
<p><strong>Status:</strong> Parsing &amp; runtime scheduling <strong>planned</strong> for post–v1.0; syntax reserved.</p>
</blockquote>
<hr />
<h2>11) Planned: Header <code>do &lt;stmt&gt;</code> Default</h2>
<p>Shared non-return action for <strong>empty</strong> matching arms.</p>
<pre lang="goblin"><code>err_count = 0

judge do err_count = err_count + 1
    bad_input():
    timed_out():
    else: say &quot;ok&quot;   /// else has its own body, so default doesn't apply here
end
</code></pre>
<hr />
<h2>12) Additional Roadmap (Post–v1.0)</h2>
<h3>12.1 Stateful vs Snapshot (for <code>judge_all</code>)</h3>
<ul>
<li><strong>Snapshot (default):</strong> evaluate all conditions once, then run matches.</li>
<li><strong>Stateful:</strong> reevaluate each arm after previous arm’s effects.</li>
</ul>
<pre lang="goblin"><code>mode = &quot;cold&quot;
judge_all stateful
    mode == &quot;cold&quot;:
        say &quot;warming&quot;
        mode = &quot;warm&quot;
    mode == &quot;warm&quot;:
        say &quot;now warm&quot;   /// runs only in stateful
end
</code></pre>
<h3>12.2 Structured Results (expr-form)</h3>
<p>Return a record instead of a raw array:</p>
<pre lang="goblin"><code>res =
    judge_all structured
        x % 2 == 0: &quot;even&quot;
        x % 3 == 0: &quot;div3&quot;
        else:       &quot;other&quot;
    end

/// res.matched   → [&quot;even&quot;]
/// res.results   → [&quot;even&quot;]
/// res.else_hit  → false
</code></pre>
<h3>12.3 Hot-Reloadable Arms</h3>
<p>Load rule arms from data, compile to AST, cache, and evaluate safely.</p>
<pre lang="goblin"><code>rules = load_json(&quot;rules.json&quot;)

act apply_dynamic_rules(obj)
    judge_all from rules using obj
        else: say &quot;no rules&quot;
    end
end
</code></pre>
<h3>12.4 Enum Payloads (Tagged Unions)</h3>
<p>Future: destructuring patterns with optional guards.</p>
<pre lang="goblin"><code>ev = Event::Click(10, 20)
judge ev using Event
    Click(x, y) if x &gt; 0 and y &gt; 0: say (&quot;clicked @ &quot; + x + &quot;,&quot; + y)
    Resize(w, h) if w*h &gt; 10000:    say &quot;big resize&quot;
    Key(code) if code == &quot;Enter&quot;:  say &quot;enter pressed&quot;
    Idle:                           say &quot;idle&quot;
end
</code></pre>
<hr />
<h2>13) Composition</h2>
<p>Treat each judge as a reusable rule set by wrapping in an <code>act</code>.</p>
<pre lang="goblin"><code>act pricing_rules(cart)
    judge_all
        cart &gt;&gt; total &gt;= $200: cart.apply_discount(15%)
        cart &gt;&gt; vip:           cart.apply_discount(10%)
        cart &gt;&gt; items &gt; 5:     cart.free_shipping
        else:                  cart.add_shipping($5)
    end
end

act checkout(cart)
    pricing_rules(cart)
    cart.charge
end
</code></pre>
<hr />
<h2>14) Implementation Status Summary</h2>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>judge</code> / <code>judge_all</code></td>
<td>✅</td>
</tr>
<tr>
<td><code>judge using</code></td>
<td>✅</td>
</tr>
<tr>
<td>Enum name matching</td>
<td>✅</td>
</tr>
<tr>
<td>Mixed expr/stmt/block bodies</td>
<td>✅</td>
</tr>
<tr>
<td>Header <code>return &lt;expr&gt;</code></td>
<td>✅</td>
</tr>
<tr>
<td>Control-flow propagation</td>
<td>✅</td>
</tr>
<tr>
<td>Weighted arms <code>[n]</code></td>
<td>🔜 planned (post–v1.0)</td>
</tr>
<tr>
<td>Header <code>do &lt;stmt&gt;</code> default</td>
<td>🔜 planned</td>
</tr>
<tr>
<td><code>judge_all stateful</code> mode</td>
<td>🔜 planned</td>
</tr>
<tr>
<td>Structured results (expr-form)</td>
<td>🔜 planned</td>
</tr>
<tr>
<td>Hot-reloadable arms</td>
<td>🔜 planned</td>
</tr>
<tr>
<td>Enum payload destructuring</td>
<td>🔜 planned</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>Design principle:</strong> <em>Other languages evaluate; Goblin judges.</em></p>

      </main>
    </div>
  </div>

  <footer class="container">
    <small>© 2025</small>
  </footer>
</body>
</html>