/// modules/scout_nav/scout.gbln
/// - TOC + breadcrumbs (page-scoped)
/// - Nav menus from nav.yall (portal-scoped)

/// ------------------------------------------------------------------------
/// Load ../site/portals/{portal}/nav.yall as a map.
/// If missing, return {} so callers don't explode.
/// ------------------------------------------------------------------------
act scout_load_nav_config(ctx)
    portal | ctx["portal"]

    if portal.nix?
        return {}
    xx

    path | "../site/portals/{portal}/nav.yall"

    if :file_exists(path) == false
        return {}
    xx

    return :yall_parse_file(path)
xx

/// ------------------------------------------------------------------------
/// Turn "password_generator_recipe.md.html" into "password generator recipe"
/// ------------------------------------------------------------------------
act slug_to_label(slug)
    label | "" + slug

    /// strip common extensions
    label | ignore_where(label, ".md.html")
    label | ignore_where(label, ".html")
    label | ignore_where(label, ".md")

    /// replace "_" with " "
    label |= :join(:split(label, "_"), " ")

    /// replace "-" with " "
    label |= :join(:split(label, "-"), " ")

    return label
xx

/// ------------------------------------------------------------------------
/// Build TOC HTML from rendered page HTML.
/// Looks for <h1>…</h1>, <h2>…</h2>, <h3>…</h3>, <h4>…</h4>
/// and assumes an <a ... id="...">Text</a> pattern inside.
/// ------------------------------------------------------------------------
act generate_toc(html_content)
    headers | []

    sweep html_content
        "<h1>" ... "</h1>" :
            anchor_id | keep_between(self, "id=\"", "\"")
            text      | trim(keep_between(self, "</a>", "<"))

            if text != "" and anchor_id != ""
                put_last!(headers, {"level": 1, "id": anchor_id, "text": text})
            xx

        "<h2>" ... "</h2>" :
            anchor_id | keep_between(self, "id=\"", "\"")
            text      | trim(keep_between(self, "</a>", "<"))

            if text != "" and anchor_id != ""
                put_last!(headers, {"level": 2, "id": anchor_id, "text": text})
            xx

        "<h3>" ... "</h3>" :
            anchor_id | keep_between(self, "id=\"", "\"")
            text      | trim(keep_between(self, "</a>", "<"))

            if text != "" and anchor_id != ""
                put_last!(headers, {"level": 3, "id": anchor_id, "text": text})
            xx

        "<h4>" ... "</h4>" :
            anchor_id | keep_between(self, "id=\"", "\"")
            text      | trim(keep_between(self, "</a>", "<"))

            if text != "" and anchor_id != ""
                put_last!(headers, {"level": 4, "id": anchor_id, "text": text})
            xx
    xx

    toc_parts | []
    for h in headers
        level | h["level"]
        id    | h["id"]
        text  | h["text"]

        item | "<li class=\"toc-item toc-level-" + string(level)
        item | item + "\"><a href=\"#"
        item | item + id + "\">" + text + "</a></li>\n"

        put_last!(toc_parts, item)
    xx

    toc_html | pack(toc_parts)

    prefix |
        "<aside class=\"toc\" aria-label=\"On this page\">" +
        "<details class=\"toc-details\" open>" +
        "<summary class=\"toc-summary\">On this page</summary>" +
        "<ul class=\"toc-list\">\n"

    suffix | "</ul></details></aside>\n"

    return prefix + toc_html + suffix
xx

/// ------------------------------------------------------------------------
/// Breadcrumbs
/// - No "Home"
/// - Root "Docs" for anything under /docs
/// - Uses sheriff-breadcrumb-* classes to match CSS / React mock
/// ------------------------------------------------------------------------
act build_breadcrumbs(ctx)
    path   | ctx["path"]
    portal | ctx["portal"]

    if path.nix? or portal.nix?
        return ""
    xx

    content_root | "../site/portals/{portal}/content"
    rel          | :path_relative_to(path, content_root)

    /// Root → no breadcrumbs
    if rel == ""
        return ""
    xx

    segs       | :split(rel, "/")
    clean_segs | []

    /// Drop empty segments + trailing index.md
    for s in segs
        if s == "" => skip
        if s == "index.md" => skip
        :put_last!(clean_segs, s)
    xx

    if clean_segs.len == 0
        return ""
    xx

    parts | []

    /// Outer wrapper – matches .sheriff-breadcrumbs box
    :put_last!(parts,
        "<nav class=\"sheriff-breadcrumbs\" aria-label=\"Breadcrumb\">"
    )

    idx | 0
    for seg in clean_segs
        is_last | (idx == clean_segs.len - 1)
        label   | slug_to_label(seg)
        safe    | :escape_html(label).title

        if is_last
            :put_last!(parts,
                "<div class=\"sheriff-breadcrumb-row\">" +
                    "<span class=\"sheriff-breadcrumb-arrow\">↳</span>" +
                    "<span class=\"sheriff-breadcrumb-current\">" + safe + "</span>" +
                "</div>"
            )
        else
            :put_last!(parts,
                "<div class=\"sheriff-breadcrumb-row\">" +
                    "<span class=\"sheriff-breadcrumb-arrow\">↳</span>" +
                    "<span class=\"sheriff-breadcrumb-link sheriff-link\">" + safe + "</span>" +
                "</div>"
            )
        xx

        idx | idx + 1
    xx

    :put_last!(parts, "</nav>")

    return :pack(parts)
xx

/// ------------------------------------------------------------------------
/// Main entry: called from the pipeline as scout::apply_tokens
/// After layout + wire_slots, before Brindle resolves tokens.
/// ------------------------------------------------------------------------
act apply_tokens(ctx)
    body | ctx["body"]
    if body.nix?
        return ctx
    xx

    /// BREADCRUMBS (page-scoped)
    breadcrumbs_html | build_breadcrumbs(ctx)
    if breadcrumbs_html != ""
        register_token("SCOUT", "BREADCRUMBS", breadcrumbs_html)
    xx

    /// TOC (page-scoped)
    toc_html | generate_toc(body)
    if toc_html != ""
        register_token("SCOUT", "TOC", toc_html)
    xx

    /// Resolve SCOUT::* for this page only
    rendered | :resolve_token(body)
    :update!(ctx["body"], rendered)

    /// Clear page-scoped tokens for the next file
    clear_token("SCOUT", "TOC")
    clear_token("SCOUT", "BREADCRUMBS")

    return ctx
xx

/// ========================================================================
/// NAV MENUS (from nav.yall + theme scout_nav.yall)
/// ========================================================================

act make_abs_href(portal, raw)
    href | :trim("" + raw)
    if href == ""
        return ""
    xx

    if href.len >= 7 and href[0:7] == "http://"
        return href
    xx
    if href.len >= 8 and href[0:8] == "https://"
        return href
    xx

    if href[0:1] == "/"
        return href
    xx

    return "/" + href
xx

/// ------------------------------------------------------------------------
/// Shared nested <ul> generator used by sidebar + header dropdowns.
/// ------------------------------------------------------------------------
act generate_nested_items(portal, items_map)
    if items_map.nix?
        return ""
    xx

    vt | :valtype(items_map)
    if vt != "map"
        return ""
    xx

    keys | :keys(items_map)
    if keys.len == 0
        return ""
    xx

    ul_items | ""

    for key in keys
        val      | items_map[key]
        val_type | :valtype(val)

        if val_type == "map"
            nested_html | generate_nested_items(portal, val)
            if nested_html == ""
                skip
            xx

            item | """
<li class="has-submenu">
  <span class="submenu-header">{key}</span>
  {nested_html}
</li>
"""
            update!(ul_items, ul_items + item)
        else
            href | make_abs_href(portal, val)
            if href == ""
                skip
            xx

            item | """
<li>
  <a class="sheriff-link" href="{href}">{key}</a>
</li>
"""
            update!(ul_items, ul_items + item)
        xx
    xx

    if ul_items == ""
        return ""
    xx

    html | """
<ul>
{ul_items}</ul>
"""
    return html
xx

/// ------------------------------------------------------------------------
/// SIDEBAR / DOCS TREE – matches old .sheriff-left-nav structure
/// ------------------------------------------------------------------------
act scout_render_sidebar(portal, menu_content)
    if menu_content.nix?
        return ""
    xx

    vt | :valtype(menu_content)
    if vt != "map"
        return ""
    xx

    keys | :keys(menu_content)
    if keys.len == 0
        return ""
    xx

    nav_items | ""
    first_key | true

    for top_key in keys
        top_val   | menu_content[top_key]
        val_type  | :valtype(top_val)

        if first_key and val_type == "map"
            nested | generate_nested_items(portal, top_val)
            if nested == ""
                skip
            xx

            item | """
<div class="section-header">
  <span>{top_key}</span>
</div>
{nested}
"""
            update!(nav_items, nav_items + item)
            update!(first_key, false)

        elif val_type == "str"
            href | make_abs_href(portal, top_val)
            if href == ""
                skip
            xx

            item | """
<li>
  <a class="sheriff-link" href="{href}">{top_key}</a>
</li>
"""
            update!(nav_items, nav_items + item)
            update!(first_key, false)

        elif val_type == "map"
            nested | generate_nested_items(portal, top_val)
            if nested == ""
                skip
            xx

            item | """
<li class="has-submenu">
  <span class="menu-header">{top_key}</span>
  {nested}
</li>
"""
            update!(nav_items, nav_items + item)
            update!(first_key, false)
        xx
    xx

    if nav_items == ""
        return ""
    xx

    html | """
<aside class="sheriff-left-nav">
{nav_items}
</aside>
"""
    return html
xx

/// ------------------------------------------------------------------------
/// FOOTER – flat compact links (same HTML / CSS as before)
/// ------------------------------------------------------------------------
act scout_render_footer(portal, footer_content)
    if footer_content.nix?
        return ""
    xx

    vt | :valtype(footer_content)
    if vt != "map"
        return ""
    xx

    keys | :keys(footer_content)
    if keys.len == 0
        return ""
    xx

    footer_links | ""
    first | true

    for text in keys
        url     | footer_content[text]
        url_str | make_abs_href(portal, url)
        if url_str == ""
            skip
        xx

        separator | ""
        if first == false
            update!(separator, " · ")
        xx

        link | """{separator}<a href="{url_str}" class="sheriff-link">{text}</a>"""
        update!(footer_links, footer_links + link)
        update!(first, false)
    xx

    if footer_links == ""
        return ""
    xx

    html | """
<div class="sheriff-footer-links">
{footer_links}</div>
"""
    return html
xx

/// ------------------------------------------------------------------------
/// HEADER NAV – matches old .sheriff-header-nav structure exactly
/// ------------------------------------------------------------------------
act generate_header_dropdown(portal, dropdown_map)
    if dropdown_map.nix?
        return ""
    xx

    keys | :keys(dropdown_map)
    if keys.len == 0
        return ""
    xx

    sections_html | ""

    for section_key in keys
        section_val  | dropdown_map[section_key]
        section_type | :valtype(section_val)

        if section_type == "str"
            href | make_abs_href(portal, section_val)
            if href == ""
                skip
            xx

            section_html | """
<div class="dropdown-section">
  <a href="{href}">{section_key}</a>
</div>
"""
            update!(sections_html, sections_html + section_html)

        elif section_type == "map"
            links_html | ""
            link_keys  | :keys(section_val)

            for link_key in link_keys
                link_href | make_abs_href(portal, section_val[link_key])
                if link_href == ""
                    skip
                xx

                link_item | """
    <li>
      <a href="{link_href}">{link_key}</a>
    </li>
"""
                update!(links_html, links_html + link_item)
            xx

            if links_html != ""
                section_html | """
<div class="dropdown-section">
  <span class="dropdown-section-title">{section_key}</span>
  <ul>
{links_html}  </ul>
</div>
"""
                update!(sections_html, sections_html + section_html)
            xx
        xx
    xx

    return sections_html
xx

act scout_render_header_nav(portal, menu_content)
    if menu_content.nix?
        return ""
    xx

    vt | :valtype(menu_content)
    if vt != "map"
        return ""
    xx

    keys | :keys(menu_content)
    if keys.len == 0
        return ""
    xx

    nav_items | ""

    for top_key in keys
        top_val   | menu_content[top_key]
        val_type  | :valtype(top_val)

        if val_type == "str"
            href | make_abs_href(portal, top_val)
            if href == ""
                skip
            xx

            item | """
<li>
  <a class="sheriff-link" href="{href}">{top_key}</a>
</li>
"""
            update!(nav_items, nav_items + item)

        elif val_type == "map"
            dropdown_html | generate_header_dropdown(portal, top_val)
            if dropdown_html == ""
                skip
            xx

            item | """
<li>
  <span class="sheriff-link">{top_key} <span class="dropdown-arrow">▼</span></span>
  <div class="dropdown-panel">
    {dropdown_html}
  </div>
</li>
"""
            update!(nav_items, nav_items + item)
        xx
    xx

    if nav_items == ""
        return ""
    xx

    html | """
<nav class="sheriff-header-nav">
  <ul>
{nav_items}  </ul>
</nav>
"""
    return html
xx

/// ------------------------------------------------------------------------
/// Built-in menu kinds:
///   - "header"      → header dropdown bar
///   - "sidebar"     → docs tree / left nav
///   - "footer_flat" → footer link row
/// Unknown kinds fall back to "sidebar" for now.
/// ------------------------------------------------------------------------
act scout_render_menu_for_kind(portal, menu_map, kind)
    if menu_map.nix?
        return ""
    xx

    vt | :valtype(menu_map)
    if vt != "map"
        return ""
    xx

    k | "" + kind

    if k == "header"
        return scout_render_header_nav(portal, menu_map)
    xx

    if k == "footer_flat"
        return scout_render_footer(portal, menu_map)
    xx

    if k == "sidebar"
        return scout_render_sidebar(portal, menu_map)
    xx

    /// Fallback
    return scout_render_sidebar(portal, menu_map)
xx

/// ------------------------------------------------------------------------
/// Load theme-specific nav mapping:
///   - Portal config: ../site/portals/{portal}/config.yall
///       theme:
///         name: outpost
///   - Theme file:    ../site/portals/{portal}/themes/{theme_name}/scout_nav.yall
///
/// If anything is missing, we log and bail (no menus).
/// ------------------------------------------------------------------------
act scout_load_theme_nav_mapping(portal)
    cfg_path | "../site/portals/{portal}/config.yall"
    if :file_exists(cfg_path) == false
        :say("SCOUT: Missing portal config.yall for portal '{portal}'")
        return nil
    xx

    cfg   | :yall_parse_file(cfg_path)
    theme | cfg["theme"]
    if theme.nix?
        :say("SCOUT: Portal '{portal}' has no theme entry in config.yall")
        return nil
    xx

    name | theme["name"]
    if name.nix?
        :say("SCOUT: Portal '{portal}' has theme section but no theme.name")
        return nil
    xx

    theme_name | "" + name

    map_path | "../site/portals/{portal}/themes/{theme_name}/scout_nav.yall"
    if :file_exists(map_path) == false
        :say("SCOUT: Theme '{theme_name}' missing scout_nav.yall")
        return nil
    xx

    cfg2    | :yall_parse_file(map_path)
    mapping | cfg2["tokens"]
    if mapping.nix?
        :say("SCOUT: Theme '{theme_name}' has no tokens section in scout_nav.yall")
        return nil
    xx

    return mapping
xx

/// ------------------------------------------------------------------------
/// Publish SCOUT::* nav tokens using:
///   - portal nav.yall (menus)
///   - theme scout_nav.yall (tokens -> { menu, kind })
///
/// Example scout_nav.yall for Outpost:
///
/// tokens:
///   DOCS_NAV:
///     menu: header
///     kind: header
///   MAIN_NAV:
///     menu: header
///     kind: header
///   DOCS_TREE:
///     menu: left_docs
///     kind: sidebar
///   FOOTER_LEFT:
///     menu: footer_left
///     kind: footer_flat
///   FOOTER_RIGHT:
///     menu: footer_right
///     kind: footer_flat
/// ------------------------------------------------------------------------
act publish_nav_tokens(portal)
    nav_path | "../site/portals/{portal}/nav.yall"
    if :file_exists(nav_path) == false
        :say("SCOUT: No nav.yall found for portal '{portal}'. Skipping menus.")
        return nil
    xx

    nav_cfg | :yall_parse_file(nav_path)
    menus   | nav_cfg["menus"]
    if menus.nix?
        :say("SCOUT: nav.yall has no menus section. Skipping menus.")
        return nil
    xx

    mapping | scout_load_theme_nav_mapping(portal)
    if mapping.nix?
        :say("SCOUT: Skipping menu render — theme mapping unavailable.")
        return nil
    xx

    token_names | :keys(mapping)

    for tname in token_names
        tcfg    | mapping[tname]
        menu_id | tcfg["menu"]
        kind    | tcfg["kind"]

        if menu_id.nix? or kind.nix?
            :say("SCOUT: Token '" ++ ("" + tname) ++ "' missing menu/kind mapping in theme.")
            skip
        xx

        menu_name | "" + menu_id
        menu_map  | menus[menu_name]
        if menu_map.nix?
            :say("SCOUT: Theme maps token '" ++ ("" + tname) ++
                 "' to menu '" ++ menu_name ++ "', but nav.yall has no such menu.")
            skip
        xx

        html | scout_render_menu_for_kind(portal, menu_map, "" + kind)
        if html == ""
            :say("SCOUT: Token '" ++ ("" + tname) ++ "' rendered empty HTML.")
            skip
        xx

        register_token("SCOUT", "" + tname, html)
    xx

    return nil
xx