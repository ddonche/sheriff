/// modules/stagehand/stagehand.gbln
/// Stagehand: backstage crew for Sheriff.
/// - Copies theme/public assets (once per portal)
/// - Wires layout slots from templates.yall into SLOT::* tokens
/// - Expands SLOT::* into the layout HTML, leaving module tokens for others

/// Copy ONLY the active theme's CSS + the portal's public/ assets.
/// Active theme is read from ../site/portals/{portal}/config.yall:
///
/// theme:
///   name: outpost
///
/// If missing, defaults to "outpost".

act resolve_theme_name(portal)
    config_path|"../site/portals/{portal}/config.yall"
    theme_name|"outpost"

    if :file_exists(config_path)
        cfg|:yall_parse_file(config_path)
        if !cfg.nix? and :valtype(cfg)=="map" and !cfg["theme"].nix?
            theme_cfg|cfg["theme"]
            if :valtype(theme_cfg)=="map" and !theme_cfg["name"].nix?
                :update!(theme_name,:trim(""+theme_cfg["name"]))
            xx
        xx
    xx

    return theme_name
xx

act copy_assets(pre_ctx)
    portal | pre_ctx["portal"]

    if portal.nix?
        :say("STAGEHAND: No portal in pre_ctx; skipping copy_assets")
        return pre_ctx
    xx

    /// ----- 1) Determine active theme name from config.yall -----
    config_path | "../site/portals/{portal}/config.yall"
    theme_name  | "outpost"   /// sensible default

    if :file_exists(config_path)
        cfg | :yall_parse_file(config_path)

        if !cfg.nix? and !cfg["theme"].nix?
            theme_cfg | cfg["theme"]

            if !theme_cfg["name"].nix?
                :update!(theme_name, :trim("" + theme_cfg["name"]))
            xx
        xx
    xx

    :say("STAGEHAND: Active theme for portal '{portal}' is '{theme_name}'")

    /// ----- 2) Copy theme CSS (single file) from sheriff-core into dist/{portal}/public/css -----
    theme_css_src   | "../sheriff-core/themes/{theme_name}/css/{theme_name}.css"
    public_css_dest | "../dist/{portal}/public/css"

    if :file_exists(theme_css_src)
        :create_dir!(public_css_dest)

        dest | "{public_css_dest}/{theme_name}.css"
        :copy_file!(theme_css_src, dest)

        :say("STAGEHAND: Copied theme CSS '{theme_name}.css' from sheriff-core")
    else
        :say("STAGEHAND: Theme CSS NOT FOUND for theme '{theme_name}' at {theme_css_src}")
    xx

    /// ----- 3) Copy portal public/ → dist/{portal}/public -----
    public_src  | "../site/portals/{portal}/public"
    public_dest | "../dist/{portal}/public"

    assets_copied | 0

    if :file_exists(public_src)
        :create_dir!(public_dest)

        for asset in :walk(public_src, "**/*.*")
            rel_path | :path_relative_to(asset, public_src)
            dir      | :dirname(rel_path)
            dest     | "{public_dest}/{rel_path}"

            if dir != ""
                dest_dir | "{public_dest}/{dir}"
                if :file_exists(dest_dir) == false
                    :create_dir!(dest_dir)
                xx
            xx

            :copy_file!(asset, dest)
            :update!(assets_copied, assets_copied + 1)
        xx

        :say("STAGEHAND: Copied {assets_copied} public assets")
    else
        :say("STAGEHAND: No public/ folder for portal '{portal}', skipping")
    xx

    /// ------------------------------------------------------------
    /// Theme override.css (portal-scoped, theme-scoped)
    /// If present in portal theme folder, copy it to dist as override.css
    /// Else ensure an empty override.css exists so layouts can always link it
    /// ------------------------------------------------------------
    override_src  | "../site/portals/{portal}/themes/{theme_name}/override.css"
    override_dest | "../dist/{portal}/public/css/override.css"

    :create_dir!("../dist/{portal}/public/css")

    if :file_exists(override_src)
        :copy_file!(override_src, override_dest)
        :say("STAGEHAND: Copied override.css from portal theme folder")
    else
        if :file_exists(override_dest) == false
            :write_text!(override_dest, "/* portal/theme overrides */\n")
            :say("STAGEHAND: Wrote empty override.css")
        else
            :say("STAGEHAND: override.css already exists; leaving as-is")
        xx
    xx

    /// ----- 4) Copy index.html from content/ to dist root if it exists -----
    index_src  | "../site/portals/{portal}/content/index.html"
    index_dest | "../dist/{portal}/index.html"

    if :file_exists(index_src)
        :copy_file!(index_src, index_dest)
        :say("STAGEHAND: Copied index.html to dist root")
    else
        :say("STAGEHAND: No index.html found in content/, skipping")
    xx

    return pre_ctx
xx

/// ----------------------------------------------------------------------
/// Helper: given ["BRINDLE::LOGO", "BADGE::VERSION"]
/// return a single string:
///   "{{{BRINDLE::LOGO}}}{{{BADGE::VERSION}}}"
/// Raw braces so Goblin doesn't eat them at parse-time.
/// ----------------------------------------------------------------------
act build_slot_value(slot_tokens)
    if slot_tokens.nix?
        return ""
    xx

    value | ""

    for tok in slot_tokens
        open  | raw "{{{"
        close | raw "}}}"
        :update!(value, value ++ open + tok + close)
    xx

    return value
xx

/// ----------------------------------------------------------------------
/// Wire layout slots → SLOT::* tokens for the current page/layout.
/// 1. Read ../site/portals/{portal}/templates.yall
/// 2. Look up layouts[layout_name].slots
/// 3. For each slot_name in that map:
///      - Build "{{{MOD::TOKEN}}}..." string
///      - register_token("SLOT", slot_name, that_string)
/// 4. Apply SLOT tokens into the current HTML via resolve_token(body)
///    (module tokens remain for their own apply_tokens steps).
/// ----------------------------------------------------------------------
act wire_slots(ctx)
    portal | ctx["portal"]
    fm     | ctx["frontmatter"]
    body   | ctx["body"]

    if portal.nix? or body.nix?
        return ctx
    xx

    /// SAFETY: ensure fm is actually a map
    if !fm.nix? and :valtype(fm) != "map"
        fm | {}
    xx

    /// 1) Determine layout name (default "docs")
    layout_name | "docs"
    if :valtype(fm) == "map" and !fm["layout"].nix?
        :update!(layout_name, :trim("" + fm["layout"]))
    xx

    /// 2) Load templates.yall and locate slots for this layout
    theme_name | resolve_theme_name(portal)
    templates_path | "../site/portals/{portal}/themes/{theme_name}/templates.yall"
    if :file_exists(templates_path) == false
        return ctx
    xx

    templates | :yall_parse_file(templates_path)
    if templates.nix? or templates["layouts"].nix?
        return ctx
    xx

    layouts_cfg | templates["layouts"]
    if layouts_cfg[layout_name].nix? or layouts_cfg[layout_name]["slots"].nix?
        return ctx
    xx

    slots_cfg | layouts_cfg[layout_name]["slots"]

    /// 3) For each slot [name, tokens], build the raw token string
    ///    and register SLOT::slot_name = "{{{MOD::TOKEN}}}..."
    /// Now register them fresh

    for pair in slots_cfg
        slot_name|pair[0]
        slot_tokens|pair[1]
        slot_value|build_slot_value(slot_tokens)
        register_token("SLOT",""+slot_name,slot_value)
    xx

    /// 4) Apply SLOT tokens into the layout HTML.
    rendered | resolve_token(body)
    :update!(ctx["body"], rendered)
    return ctx
xx