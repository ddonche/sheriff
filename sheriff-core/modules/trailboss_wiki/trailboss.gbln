/// modules/trailboss_wiki/trailboss.gbln
/// Wikilinks + routing for Sheriff (JSON-based).

import modules/trailboss_wiki/routes_json as rjson

/// ======================================================================
/// 1) ROUTE JSON GENERATION (ONE routes.json PER PORTAL)
/// ======================================================================

/// Scheduled event: called via Sheriff's :summon(ctx, schedule)
/// events.yall:
///   - trailboss::build_routes_once
///   - frontier::strip_frontmatter
///   - markdown_core::render
///   - trailboss::process_wikilinks
act build_routes_once(ctx)
    portal | pre_ctx["portal"]
    if portal.nix? => return ctx

    rjson::build_routes_json_for_portal(portal)
    return ctx
xx

/// ======================================================================
/// 2) LOOKUP HELPERS (USING routes.json ARRAY)
/// ======================================================================

/// routes is an ARRAY of metadata objects; find the first with matching slug.
act find_route_meta(routes, slug)
    if routes.nix? => return nil

    for meta in routes
        if meta["slug"] == slug => return meta
    xx

    return nil
xx

act find_href_for_slug(ctx, portal, slug)
    /// Fallback pattern used throughout
    fallback | ""
    if portal.nix?
        fallback |= "/{slug}.html"
    else
        fallback |= "/{portal}/{slug}.html"
    xx
    
    if slug.nix?
        if portal.nix? => return "/index.html"
        return "/{portal}/index.html"
    xx
    
    src | ctx["path"]
    if src.nix? => return fallback
    
    /// Derive portal root from ctx["path"]
    portal_root | :keep_before(src, "/content/")
    if portal_root.nix? => portal_root |= "../site/portals/{portal}"
    
    routes_path | "{portal_root}/routes.json"
    if :file_exists(routes_path) == false => return fallback
    
    parsed | :read_json(routes_path)
    routes | parsed["routes"]
    if routes.nix? => return fallback
    
    for meta in routes
        if meta.nix? => skip
        if meta["slug"] == slug
            href_abs | meta["href"]
            if href_abs.nix? => href_abs |= "/{portal}/{slug}.html"
            return href_abs
        xx
    xx
    
    /// No match â†’ fallback
    return fallback
xx

/// Small helper to build the final <a> tag.
act build_wikilink_html(href, label, is_external)
    html_parts | []
    :put_last!(html_parts, "<a href=\"")
    :put_last!(html_parts, href)
    :put_last!(html_parts, "\">")
    :put_last!(html_parts, label)
    if is_external => :put_last!(html_parts, "<span class=\"external-link-icon\" aria-hidden=\"true\"></span>")
    :put_last!(html_parts, "</a>")
    return :pack(html_parts)
xx

/// ======================================================================
/// 3) RESOLVE A SINGLE WIKILINK
/// ======================================================================

/// HTML post-processor for Sheriff wikilinks.
///
/// Supported patterns in rendered HTML:
///   [[Badge]]
///   [[Badge | Badge Module]]
///   [[Some Page#Section]]
///   [[https://goblinlang.org]]
///   [[https://goblinlang.org | Goblin]]
///   [[p/loricism/infinitum]]
///   [[p/loricism/infinitum | The Infinitum]]
///   [[u/janden]]
///   [[u/janden | Janden, Keeper of Goblins]]
act resolve_wikilink(inner, ctx, portal)
    if inner.nix? => return ""

    text | :trim(inner)
    if text.nix? => return ""

    core | :keep_between(text, "[[", "]]")
    if core.nix? => core |= text

    inner_text | :trim(core)
    if inner_text.nix? => return ""

    /// Split only if a pipe actually exists.
    before_pipe | :keep_before(inner_text, "|")
    after_pipe  | :keep_after(inner_text, "|")

    judge
        before_pipe.nix? and after_pipe.is_nix?:
            target_raw | inner_text
            label_raw  | ""
        else:
            target_raw | :trim(before_pipe)
            label_raw  | :trim(after_pipe)
    xx

    lower_target | :lower(target_raw)
    is_external  | :starts_with(lower_target, "http://") or :starts_with(lower_target, "https://")
    is_portal    | :starts_with(target_raw, "p/")
    is_user      | :starts_with(target_raw, "u/")

    judge
        is_external:
            href  | target_raw
            label | label_raw
            if label.nix? => label |= target_raw
            return build_wikilink_html(href, label, true)

        is_portal:
            portal_name | :keep_between(target_raw, "p/", "/")
            rest | :keep_after(target_raw, "p/{portal_name}/")

            if portal_name.nix? or rest.nix?
                href  | "#"
                label | label_raw
                if label.nix? => label |= target_raw
                return build_wikilink_html(href, label, false)
            xx

            portal_root   | "../site/portals/{portal_name}"
            portal_exists | :file_exists(portal_root)

            page   | :trim(:keep_before(rest, "#"))
            anchor | :trim(:keep_after(rest, "#"))

            if page.nix? => page |= rest

            slug | page
            slug |= :lower(slug)
            :update_where!(slug, " ", "-")
            :update_where!(slug, "_", "-")

            href | ""

            if portal_exists
                :update!(href, find_href_for_slug(ctx, portal_name, slug))
                if !anchor.nix? => :update!(href, "{href}#{anchor}")
            else
                :update!(href, "/p/{portal_name}/{slug}.html")
                if !anchor.nix? => :update!(href, "{href}#{anchor}")
            xx

            label | label_raw
            if label.nix? => :update!(label, target_raw)

            return build_wikilink_html(href, label, false)

        is_user:
            username | :keep_after(target_raw, "u/")
            if username.nix?
                href  | "#"
                label | label_raw
                if label.nix? => label |= target_raw
                return build_wikilink_html(href, label, false)
            xx

            href | "/users/{username}"
            label | label_raw
            if label.nix? => label |= "@" + username

            return build_wikilink_html(href, label, false)

        else:
            page   | :trim(:keep_before(target_raw, "#"))
            anchor | :trim(:keep_after(target_raw, "#"))

            if page.nix? => page |= target_raw

            slug | :lower(page)
            :update_where!(slug, " ", "-")
            :update_where!(slug, "_", "-")

            href | find_href_for_slug(ctx, portal, slug)
            if !anchor.nix? => href |= "{href}#{anchor}"

            label | inner_text

            return build_wikilink_html(href, label, false)
    xx
xx

/// ======================================================================
/// 4) PROCESS ALL WIKILINKS IN A PAGE
/// ======================================================================

act process_wikilinks(ctx)
    body   | ctx["body"]
    portal | ctx["portal"]

    if body.nix? => return ctx
    if portal.nix? => return ctx

    result | body

    sweep body
        "[[" ... "]]":
            repl | resolve_wikilink(self, ctx, portal)
            if !repl.nix? => :update_where!(result, self, repl)
    xx

    :update!(ctx["body"], result)
    return ctx
xx