/// modules/trailboss_wiki/trailboss.gbln
/// Wikilinks + routing for Sheriff (JSON-based).
///
/// NOTE:
/// In Goblin, `x.nix?` already means **nil OR empty**.
/// So this file uses **ONLY** `.nix?` for presence/emptiness checks.
/// No more `x.nix? or x == ""` garbage.

import modules/trailboss_wiki/routes_json as rjson

/// ======================================================================
/// 0) TINY NORMALIZERS (KEEP THIS FILE SANE)
/// ======================================================================

/// Return trimmed string, or "" if nil/empty.
act s_trim(v)
    if v.nix? => return ""
    return :trim("" + v)
xx

/// Normalize path slashes to forward.
act path_norm(p)
    if p.nix? => return ""
    out | "" + p
    :update_where!(out, "\\", "/")
    return out
xx

/// ======================================================================
/// 1) ROUTE JSON GENERATION (ONE routes.json PER PORTAL)
/// ======================================================================

act build_routes_once(pre_ctx)
    if pre_ctx.nix?
        :say("TRAILBOSS.build_routes_once: pre_ctx is nix; skipping routes.json.")
        return pre_ctx
    xx

    portal | pre_ctx["portal"]
    if portal.nix?
        :say("TRAILBOSS.build_routes_once: portal missing; skipping routes.json.")
        return pre_ctx
    xx

    :say("TRAILBOSS: building routes.json for portal = {portal}")
    rjson::build_routes_json_for_portal(portal)

    return pre_ctx
xx

/// ======================================================================
/// 1b) PER-PAGE ctx["href"] (ABSOLUTE HREF FOR CURRENT PAGE)
/// ======================================================================

act attach_href(ctx)
    portal | ctx["portal"]
    src    | ctx["path"]

    if portal.nix? => return ctx
    if src.nix?    => return ctx

    src_norm | path_norm(src)

    /// derive rel from the real source path under content/
    portal_root | derive_portal_root_from_ctx(ctx, portal)

    prefix | "{portal_root}/content/"
    rel    | :keep_after(src_norm, prefix)

    if rel.nix?
        /// fallback: older path layout
        prefix2 | "../site/portals/{portal}/content/"
        rel     | :keep_after(src_norm, prefix2)
    xx

    if rel.nix? => rel | ""
    rel |= path_norm(rel)

    rel_no_ext | :keep_before(rel, ".md")
    if rel_no_ext.nix?
        rel_no_ext |= :keep_before(rel, ".")
        if rel_no_ext.nix? => rel_no_ext | ""
    xx

    rel_no_ext |= path_norm(rel_no_ext)

    /// same rule as routes.json uses
    cfg      | rjson::load_cfg(portal)
    url_root | rjson::get_url_root(cfg)

    href_abs | rjson::build_href(url_root, rel_no_ext)

    /// Always set the key so downstream reads never crash
    :update!(ctx["href"], href_abs)

    return ctx
xx

/// ======================================================================
/// 2) CONFIG + MOUNT HELPERS
/// ======================================================================

/// Load portal config (or nil if missing)
act load_cfg(portal)
    path | "../site/portals/{portal}/config.yall"
    if :file_exists(path) == false
        return nil
    xx
    return :yall_parse_file(path)
xx

/// Defensive string cleaner:
/// - casts to string
/// - strips anything after '#'
/// - trims
/// - strips wrapping quotes if present
act clean_cfg_string(v)
    if v.nix? => return ""

    s | "" + v

    /// strip inline comments if they somehow get through
    left | :keep_before(s, "#")
    if !left.nix?
        left_t | :trim(left)
        if !left_t.nix?
            :update!(s, "" + left_t)
        xx
    xx

    s |= :trim(s)

    /// strip wrapping quotes if present
    if :starts_with(s, "\"") and :ends_with(s, "\"")
        inner | :keep_between(s, "\"", "\"")
        if !inner.nix?
            :update!(s, inner)
        xx
    xx

    return :trim(s)
xx

/// Determine where a portal is mounted in dist.
/// Rules:
/// - if routing.dist_root is nix or == "default" => ROOT mount (no prefix)
/// - else => "/{dist_root}"
act portal_mount(portal)
    cfg | load_cfg(portal)
    if cfg.nix? => return ""

    routing | cfg["routing"]
    if routing.nix?
        return ""
    xx
    if :valtype(routing) != "map"
        return ""
    xx

    dr | routing["dist_root"]
    dr |= clean_cfg_string(dr)

    if dr.nix?        => return ""
    if dr == "default" => return ""

    return "/" + dr
xx

/// ======================================================================
/// 3) SHARED HELPERS
/// ======================================================================

act normalize_to_slug(page)
    if page.nix? => return ""

    cleaned | "" + page
    :update_where!(cleaned, " (module)", "")
    :update_where!(cleaned, "(module)", "")
    :update_where!(cleaned, "(", "")
    :update_where!(cleaned, ")", "")
    cleaned |= :trim(cleaned)

    if cleaned.nix? => return ""

    slug | :lower(cleaned)
    :update_where!(slug, " ", "-")
    :update_where!(slug, "_", "-")

    return slug
xx

act split_anchor(text)
    t | s_trim(text)
    if t.nix? => return {"page": "", "anchor": ""}

    page   | s_trim(:keep_before(t, "#"))
    anchor | s_trim(:keep_after(t, "#"))

    if page.nix?
        page |= t
    xx
    if anchor.nix?
        anchor | ""
    xx

    return {"page": page, "anchor": anchor}
xx

act derive_portal_root_from_ctx(ctx, portal)
    src | ctx["path"]
    if src.nix? => return "../site/portals/{portal}"

    src_norm | path_norm(src)

    root | :keep_before(src_norm, "/content/")
    if root.nix?
        root |= "../site/portals/{portal}"
    xx

    return root
xx

act load_routes_for_portal(ctx, portal)
    if portal.nix? => return []

    portal_root | derive_portal_root_from_ctx(ctx, portal)
    routes_path | "{portal_root}/routes.json"

    if :file_exists(routes_path) == false
        return []
    xx

    parsed | :read_json(routes_path)
    if parsed.nix? => return []

    routes | parsed["routes"]
    if routes.nix? => return []
    if :valtype(routes) != "array" => return []

    return routes
xx

act lookup_href_by_slug(ctx, portal, slug)
    if portal.nix? => return ""
    if slug.nix?   => return ""

    routes | load_routes_for_portal(ctx, portal)
    if :valtype(routes) != "array" => return ""

    for meta in routes
        if meta.nix? => skip
        if meta["slug"] == slug
            href_abs | meta["href"]
            if !href_abs.nix?
                return "" + href_abs
            xx
        xx
    xx

    return ""
xx

act lookup_slug_by_href(ctx, portal, href_abs)
    if portal.nix?   => return ""
    if href_abs.nix? => return ""

    routes | load_routes_for_portal(ctx, portal)
    if :valtype(routes) != "array" => return ""

    href_s | "" + href_abs

    for meta in routes
        if meta.nix? => skip
        h | meta["href"]
        if h.nix? => skip
        if ("" + h) == href_s
            s | meta["slug"]
            if !s.nix?
                return "" + s
            xx
        xx
    xx

    return ""
xx

/// ======================================================================
/// CODE STASH (PREVENT TOKEN/WIKILINK PROCESSING INSIDE CODE/PRE)
/// ======================================================================

act stash_code_segments(html)
    if html.nix? => return {"html": "", "stash": []}

    out   | "" + html
    stash | []
    n     | 0

    /// predeclare once for this block
    seg | ""
    key | ""

    /// Stash fenced blocks first (<pre ... </pre>)
    sweep out
        "<pre" ... "</pre>":
            seg |= "" + self
            key |= "@@TB_CODE_{n}@@"
            :put_last!(stash, {"k": key, "v": seg})
            :update_where!(out, seg, key)
            n += 1
    xx

    /// Then stash inline code (<code ... </code>)
    sweep out
        "<code" ... "</code>":
            seg |= "" + self
            key |= "@@TB_CODE_{n}@@"
            :put_last!(stash, {"k": key, "v": seg})
            :update_where!(out, seg, key)
            n += 1
    xx

    return {"html": out, "stash": stash}
xx

act restore_code_segments(html, stash)
    if html.nix? => return ""
    out | "" + html

    if stash.nix? => return out
    if :valtype(stash) != "array" => return out

    for item in stash
        if item.nix? => skip
        k | item["k"]
        v | item["v"]
        if k.nix? => skip
        if v.nix? => skip
        :update_where!(out, "" + k, "" + v)
    xx

    return out
xx

/// ======================================================================
/// 4) MISSING PAGE ROUTING (NO FALLBACKS, NO "#")
/// ======================================================================

act missing_page_href()
    return "/docs/missing.html"
xx

/// ======================================================================
/// 5) HTML SAFETY + FINAL <a>
/// ======================================================================

act escape_attr(s)
    if s.nix? => return ""
    out | "" + s
    :update_where!(out, "\"", "&quot;")
    return out
xx

act escape_text(s)
    if s.nix? => return ""
    out | "" + s
    :update_where!(out, "&", "&amp;")
    :update_where!(out, "<", "&lt;")
    :update_where!(out, ">", "&gt;")
    return out
xx

/// ======================================================================
/// LINK HTML (NO "#", STRICT MISSING PAGE)
/// ======================================================================

act build_wikilink_html(href, label, is_external, klass)
    /// Normalize inputs
    href_s  | s_trim(href)
    label_s | s_trim(label)
    klass_s | s_trim(klass)

    /// Hard guarantee: href is never nix (and never "#")
    if href_s.nix?
        href_s |= missing_page_href()
    xx

    /// Label defaults to href
    if label_s.nix?
        label_s |= href_s
    xx

    /// Class defaults
    if klass_s.nix?
        klass_s |= "sheriff-link"
    xx

    /// Auto-mark missing-page links (matches mounted or root)
    if :ends_with(href_s, "/docs/missing.html")
        klass_s |= "{klass_s} sheriff-missing-link"
    xx

    href_s  |= escape_attr(href_s)
    label_s |= escape_text(label_s)
    klass_s |= escape_attr(klass_s)

    html_parts | []
    :put_last!(html_parts, "<a href=\"")
    :put_last!(html_parts, href_s)
    :put_last!(html_parts, "\" class=\"")
    :put_last!(html_parts, klass_s)
    :put_last!(html_parts, "\">")
    :put_last!(html_parts, label_s)

    if is_external
        :put_last!(html_parts, "<span class=\"external-link-icon\" aria-hidden=\"true\"></span>")
    xx

    :put_last!(html_parts, "</a>")
    return :pack(html_parts)
xx

act build_bad_video_embed(raw_inner)
    msg | escape_text("" + raw_inner)
    return :pack([
        "<div class=\"sheriff-video sheriff-video-bad\">",
          "<div class=\"sheriff-video-bad-label\">Invalid video tag:</div>",
          "<code class=\"sheriff-video-bad-code\">", msg, "</code>",
        "</div>"
    ])
xx

/// ======================================================================
/// 6) RESOLVE A SINGLE WIKILINK
/// ======================================================================

act resolve_wikilink(inner, ctx, portal)
    if inner.nix? => return ""

    raw | s_trim(inner)
    if raw.nix? => return ""

    core | :keep_between(raw, "[[", "]]")
    if core.nix?
        core |= raw
    xx

    inner_text | s_trim(core)
    if inner_text.nix? => return ""

    /// Reject deprecated video shorthand
    if :starts_with(:lower(inner_text), "video|")
        return build_bad_video_embed(inner_text)
    xx

    /// IMAGE WIKILINK (fixed shape)
    if :starts_with(inner_text, "image:")
        body | :keep_after(inner_text, "image:")
        if body.nix? => return ""

        parts | :split(body, "|")
        if parts.nix? => return ""

        filename | parts[0]
        size     | parts[1]
        align    | parts[2]
        caption  | parts[3]

        if filename.nix? => return ""

        if size.nix?  => size  | "full"
        if align.nix? => align | "center"
        if caption.nix? => caption | ""

        /// mount-aware src
        m | portal_mount(portal)
        src | "/public/images/{filename}"
        if !m.nix?
            src | "{m}/public/images/{filename}"
        xx

        src_e | escape_attr(src)
        cap_a | escape_attr(caption)
        cap_t | escape_text(caption)

        img_class | "sheriff-image sheriff-image-{size} sheriff-align-{align}"

        parts_out | []
        :put_last!(parts_out, "<span class=\"sheriff-image-block\">")
        :put_last!(parts_out, "<img src=\"")
        :put_last!(parts_out, src_e)
        :put_last!(parts_out, "\" alt=\"")
        :put_last!(parts_out, cap_a)
        :put_last!(parts_out, "\" class=\"")
        :put_last!(parts_out, img_class)
        :put_last!(parts_out, "\">")
        :put_last!(parts_out, "<span class=\"sheriff-image-caption\">")
        :put_last!(parts_out, cap_t)
        :put_last!(parts_out, "</span>")
        :put_last!(parts_out, "</span>")

        return :pack(parts_out)
    xx

    /// ======================================================================
    /// FOCUS PANEL (STRICT SHAPE)
    /// ======================================================================
    /// REQUIRED:
    /// [[focuspanel:filename.png|size|align|caption]]
    if :starts_with(inner_text, "focuspanel:")
        body | :keep_after(inner_text, "focuspanel:")
        if body.nix? => return ""

        parts | :split(body, "|")
        if parts.nix? => return ""

        /// STRICT: must be exactly 4 segments
        if parts.len < 4
            return ""
        xx

        filename | parts[0]
        size     | parts[1]
        align    | parts[2]
        caption  | parts[3]

        if filename.nix? => return ""
        if size.nix?     => return ""
        if align.nix?    => return ""
        if caption.nix?  => caption | ""

        /// mount-aware src
        m | portal_mount(portal)
        src | "/public/images/{filename}"
        if !m.nix?
            src | "{m}/public/images/{filename}"
        xx

        src_e | escape_attr(src)
        cap_a | escape_attr(caption)
        cap_t | escape_text(caption)

        out | []
        :put_last!(out, "<div class=\"sheriff-focus-panel\" data-focus-panel data-default-src=\"")
        :put_last!(out, src_e)
        :put_last!(out, "\" data-default-caption=\"")
        :put_last!(out, cap_a)
        :put_last!(out, "\">")

        :put_last!(out, "<img class=\"sheriff-focus-panel-img\" src=\"")
        :put_last!(out, src_e)
        :put_last!(out, "\" alt=\"")
        :put_last!(out, cap_a)
        :put_last!(out, "\">")

        :put_last!(out, "<div class=\"sheriff-focus-panel-caption\">")
        :put_last!(out, cap_t)
        :put_last!(out, "</div>")

        :put_last!(out, "</div>")

        return :pack(out)
    xx

    /// FOCUS LINK (drives the focus panel on hover)
    /// [[focus:image:filename.png|Label]]
    if :starts_with(inner_text, "focus:")
        rest | :keep_after(inner_text, "focus:")
        if rest.nix? => return ""

        parts | :split(rest, "|")
        if parts.nix? => return ""
        if parts.len < 2 => return ""

        img_ref | parts[0]
        label   | parts[1]

        if img_ref.nix? => return ""
        if label.nix?   => label | ""

        if :starts_with(img_ref, "image:") == false
            return ""
        xx

        filename | :keep_after(img_ref, "image:")
        if filename.nix? => return ""

        /// mount-aware src
        m | portal_mount(portal)
        src | "/public/images/{filename}"
        if !m.nix?
            src | "{m}/public/images/{filename}"
        xx

        src_e   | escape_attr(src)
        cap_a   | escape_attr(label)
        label_t | escape_text(label)

        out | []
        :put_last!(out, "<span class=\"sheriff-link sheriff-focus-link\" data-focus-src=\"")
        :put_last!(out, src_e)
        :put_last!(out, "\" data-focus-caption=\"")
        :put_last!(out, cap_a)
        :put_last!(out, "\" tabindex=\"0\" role=\"link\">")
        :put_last!(out, label_t)
        :put_last!(out, "</span>")
        return :pack(out)
    xx

    /// VIDEO (same convention as image: and focuspanel:)
    /// [[video:youtube|VIDEO_ID|size|align|Caption]]
    /// [[video:vimeo|VIDEO_ID|size|align|Caption]]
    if :starts_with(inner_text, "video:")
        body | :keep_after(inner_text, "video:")
        if body.nix? => return ""

        parts | :split(body, "|")
        if parts.nix? => return ""

        provider | parts[0]
        vid      | parts[1]
        size     | parts[2]
        align    | parts[3]
        caption  | parts[4]

        if provider.nix? => return ""
        if vid.nix?      => return ""

        if size.nix?  => size  | "full"
        if align.nix? => align | "center"
        if caption.nix? => caption | ""

        provider |= :lower(:trim(provider))
        vid      |= :trim(vid)
        size     |= :lower(:trim(size))
        align    |= :lower(:trim(align))
        caption  |= :trim(caption)

        /// Build embed URL
        base | ""
        if provider == "vimeo"
            base |= "https://player.vimeo.com/video/"
        else
            base |= "https://www.youtube-nocookie.com/embed/"
        xx

        src | base + vid
        src_e | escape_attr(src)

        cap_a | escape_attr(caption)
        cap_t | escape_text(caption)

        wrap_class | "sheriff-video sheriff-video-{size}"
        frame_class | "sheriff-video-frame sheriff-align-{align}"

        out | []
        :put_last!(out, "<div class=\"")
        :put_last!(out, wrap_class)
        :put_last!(out, "\">")

        :put_last!(out, "<div class=\"")
        :put_last!(out, frame_class)
        :put_last!(out, "\">")

        :put_last!(out, "<iframe src=\"")
        :put_last!(out, src_e)
        :put_last!(out, "\" title=\"")
        :put_last!(out, cap_a)
        :put_last!(out, "\" loading=\"lazy\"")
        :put_last!(out, " allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"")
        :put_last!(out, " allowfullscreen")
        :put_last!(out, " referrerpolicy=\"strict-origin-when-cross-origin\"")
        :put_last!(out, "></iframe>")

        :put_last!(out, "</div>")

        :put_last!(out, "<div class=\"sheriff-video-caption\">")
        :put_last!(out, cap_t)
        :put_last!(out, "</div>")

        :put_last!(out, "</div>")

        return :pack(out)
    xx

    /// ======================================================
    /// WIKILINK LOGIC (STRICT: routes.json OR missing page)
    /// ======================================================

    link_part  | :trim(:keep_before(inner_text, "|"))
    label_part | :trim(:keep_after(inner_text, "|"))

    if link_part.nix?
        link_part |= inner_text
    xx

    link_part  |= :trim(link_part)
    label_part |= :trim(label_part)

    display_label | label_part
    if display_label.nix?
        display_label |= link_part
    xx

    lower_link  | :lower(link_part)
    is_external | :starts_with(lower_link, "http://") or :starts_with(lower_link, "https://")
    is_portal   | :starts_with(link_part, "p/")
    is_user     | :starts_with(link_part, "u/")

    judge
        is_external:
            return build_wikilink_html(link_part, display_label, true, "sheriff-link")

        is_portal:
            portal_name | :keep_between(link_part, "p/", "/")
            rest        | :keep_after(link_part, "p/{portal_name}/")

            if portal_name.nix? => return build_wikilink_html(missing_page_href(), display_label, false, "sheriff-link sheriff-missing-link")
            if rest.nix?        => return build_wikilink_html(missing_page_href(), display_label, false, "sheriff-link sheriff-missing-link")

            parts  | split_anchor(rest)
            page   | parts["page"]
            anchor | parts["anchor"]

            slug | normalize_to_slug(page)
            if slug.nix? => return build_wikilink_html(missing_page_href(), display_label, false, "sheriff-link sheriff-missing-link")

            href  | lookup_href_by_slug(ctx, portal_name, slug)
            klass | "sheriff-link"

            if href.nix?
                href  |= missing_page_href()
                klass |= " sheriff-missing-link"
            xx

            if !anchor.nix?
                href |= "{href}#{anchor}"
            xx

            return build_wikilink_html(href, display_label, false, klass)

        is_user:
            username | :keep_after(link_part, "u/")
            if username.nix?
                return build_wikilink_html(missing_page_href(), display_label, false, "sheriff-link sheriff-missing-link")
            xx
            return build_wikilink_html("/users/{username}", display_label, false, "sheriff-link")

        else:
            parts  | split_anchor(link_part)
            page   | parts["page"]
            anchor | parts["anchor"]

            slug | normalize_to_slug(page)
            if slug.nix?
                return build_wikilink_html(missing_page_href(), display_label, false, "sheriff-link sheriff-missing-link")
            xx

            href  | lookup_href_by_slug(ctx, portal, slug)
            klass | "sheriff-link"

            if href.nix?
                href  |= missing_page_href()
                klass |= " sheriff-missing-link"
            xx

            if !anchor.nix?
                href |= "{href}#{anchor}"
            xx

            return build_wikilink_html(href, display_label, false, klass)
    xx
xx

/// ======================================================================
/// 7) PROCESS ALL WIKILINKS IN A PAGE
/// ======================================================================

act process_wikilinks(ctx)
    body   | ctx["body"]
    portal | ctx["portal"]

    if body.nix?   => return ctx
    if portal.nix? => return ctx

    /// --- STASH CODE/PRE so we don't mutate code examples ---
    stashed | stash_code_segments(body)
    work    | stashed["html"]
    stash   | stashed["stash"]

    result | "" + work
    focus_html | ""
    core | "" 
    repl_raw | ""
    repl | ""

    sweep work
        "[[" ... "]]":
            if self.nix? => skip

            core |= :trim(:keep_between(self, "[[", "]]"))
            if core.nix? => skip

            if :starts_with(core, "focuspanel:")
                if focus_html.nix?
                    html_raw | resolve_wikilink(self, ctx, portal)
                    if !html_raw.nix?
                        :update!(focus_html, "" + html_raw)
                    xx
                xx

                :update_where!(result, self, "")
                skip
            xx

            repl_raw |= resolve_wikilink(self, ctx, portal)
            if repl_raw.nix? => skip

            repl |= "" + repl_raw
            if repl.nix? => skip

            :update_where!(result, self, repl)
    xx

    /// Replace SITE token AFTER wikilinks â€” still safe because code is stashed.
    if focus_html.nix? => focus_html | ""
    :update_where!(result, "{{{SITE::FOCUS_PANEL}}}", focus_html)
    :update_where!(result, "{{{TRAILBOSS::FOCUS_PANEL}}}", focus_html)

    /// --- RESTORE CODE/PRE blocks ---
    final | restore_code_segments(result, stash)

    :update!(ctx["body"], final)
    return ctx
xx

/// ======================================================================
/// 8) PUBLISH CANONICAL WIKILINK FOR CURRENT PAGE
/// ======================================================================

act publish_canonical_link(ctx)
    portal | ctx["portal"]
    src    | ctx["path"]
    body   | ctx["body"]

    if portal.nix? => return ctx
    if src.nix?    => return ctx
    if body.nix?   => return ctx

    src_norm | path_norm(src)

    /// WORKING SLUG DERIVATION (the one you already had)
    stem_name | :stem(src_norm)
    slug      | normalize_to_slug(stem_name)
    if slug.nix? => return ctx

    canonical | "[[{slug}]]"

    html | """
    <div class="sheriff-canon-wrap">
      <span class="sheriff-canon-text">{canonical}</span>
      <button
        class="copy-wikilink"
        type="button"
        data-wikilink="{canonical}"
        aria-label="Copy canonical wikilink">
        <svg
          class="copy-wikilink-icon"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          aria-hidden="true">
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
          <path d="M5 15H4a 2 2 0 0 1-2-2V4a 2 2 0 0 1 2-2h9a 2 2 0 0 1 2 2v1"/>
        </svg>
      </button>
    </div>
    """

    updated | "" + body
    :update_where!(updated, "{{{TRAILBOSS::CANONLINK}}}", html)
    :update!(ctx["body"], updated)

    return ctx
xx