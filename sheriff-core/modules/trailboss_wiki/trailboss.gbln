/// modules/trailboss_wiki/trailboss.gbln
/// Wikilinks + routing for Sheriff (JSON-based).

import modules/trailboss_wiki/routes_json as rjson

/// ======================================================================
/// 1) ROUTE JSON GENERATION (ONE routes.json PER PORTAL)
/// ======================================================================

act build_routes_once(pre_ctx)
    if pre_ctx.nix?
        :say("TRAILBOSS.build_routes_once: pre_ctx is nil; skipping routes.json.")
        return pre_ctx
    xx

    portal | pre_ctx["portal"]
    if portal.nix?
        :say("TRAILBOSS.build_routes_once: portal missing in pre_ctx; skipping routes.json.")
        return pre_ctx
    xx

    :say("TRAILBOSS: building routes.json for portal = {portal}")
    rjson::build_routes_json_for_portal(portal)

    return pre_ctx
xx

/// ======================================================================
/// 1b) PER-PAGE ctx["href"] (ABSOLUTE HREF FOR CURRENT PAGE)
/// ======================================================================

act attach_href(ctx)
    portal | ctx["portal"]
    src    | ctx["path"]

    if portal.nix? => return ctx
    if src.nix?    => return ctx

    src_norm | "" + src
    :update_where!(src_norm, "\\", "/")

    /// derive rel from the real source path under content/
    portal_root | derive_portal_root_from_ctx(ctx, portal)

    prefix | "{portal_root}/content/"
    rel    | :keep_after(src_norm, prefix)

    if rel.nix? or rel == ""
        prefix2 | "../site/portals/{portal}/content/"
        rel     | :keep_after(src_norm, prefix2)
    xx

    if rel.nix? => rel | ""
    :update_where!(rel, "\\", "/")

    rel_no_ext | :keep_before(rel, ".md")
    if rel_no_ext.nix? or rel_no_ext == ""
        rel_no_ext |= :keep_before(rel, ".")
        if rel_no_ext.nix? => rel_no_ext | ""
    xx

    :update_where!(rel_no_ext, "\\", "/")

    /// same rule as routes.json uses
    cfg      | rjson::load_cfg(portal)
    url_root | rjson::get_url_root(cfg)

    href_abs | rjson::build_href(url_root, rel_no_ext)

    /// Always set the key so downstream reads never crash
    :update!(ctx["href"], href_abs)

    return ctx
xx

/// ======================================================================
/// 2) CONFIG + MOUNT HELPERS
/// ======================================================================

/// Load portal config (or nil if missing)
act load_cfg(portal)
    path | "../site/portals/{portal}/config.yall"
    if :file_exists(path) == false
        return nil
    xx
    return :yall_parse_file(path)
xx

/// Defensive string cleaner:
/// - casts to string
/// - strips anything after '#'
/// - trims
/// - strips wrapping quotes if present
act clean_cfg_string(v)
    if v.nix? => return ""

    s | "" + v

    /// strip inline comments if they somehow get through
    left | :keep_before(s, "#")
    if !left.nix? and :trim(left) != ""
        :update!(s, "" + left)
    xx

    s |= :trim(s)

    /// strip wrapping quotes if present
    if :starts_with(s, "\"") and :ends_with(s, "\"")
        inner | :keep_between(s, "\"", "\"")
        if !inner.nix?
            :update!(s, inner)
        xx
    xx

    return :trim(s)
xx

/// Determine where a portal is mounted in dist.
/// Rules:
/// - if routing.dist_root missing/empty or == "default" => ROOT mount (no prefix)
/// - else => "/{dist_root}"
act portal_mount(portal)
    cfg | load_cfg(portal)
    if cfg.nix? => return ""     /// treat as root if unknown

    routing | cfg["routing"]
    if routing.nix? or :valtype(routing) != "map"
        return ""
    xx

    dr | routing["dist_root"]
    dr | clean_cfg_string(dr)

    if dr == "" => return ""
    if dr == "default" => return ""

    return "/" + dr
xx

/// ======================================================================
/// 3) SHARED HELPERS
/// ======================================================================

act normalize_to_slug(page)
    if page.nix? => return ""

    cleaned | "" + page
    :update_where!(cleaned, " (module)", "")
    :update_where!(cleaned, "(module)", "")
    :update_where!(cleaned, "(", "")
    :update_where!(cleaned, ")", "")
    cleaned |= :trim(cleaned)

    slug | :lower(cleaned)
    :update_where!(slug, " ", "-")
    :update_where!(slug, "_", "-")

    return slug
xx

act split_anchor(text)
    page   | :trim(:keep_before(text, "#"))
    anchor | :trim(:keep_after(text, "#"))

    if page.nix? or page == ""
        page |= text
    xx

    if anchor.nix?
        anchor | ""
    xx

    return {"page": page, "anchor": anchor}
xx

act derive_portal_root_from_ctx(ctx, portal)
    src | ctx["path"]
    if src.nix? => return "../site/portals/{portal}"

    src_norm | "" + src
    :update_where!(src_norm, "\\", "/")

    root | :keep_before(src_norm, "/content/")
    if root.nix? or root == ""
        root |= "../site/portals/{portal}"
    xx

    return root
xx

act load_routes_for_portal(ctx, portal)
    if portal.nix? or portal == "" => return []

    portal_root | derive_portal_root_from_ctx(ctx, portal)
    routes_path | "{portal_root}/routes.json"

    if :file_exists(routes_path) == false
        return []
    xx

    parsed | :read_json(routes_path)
    routes | parsed["routes"]

    if routes.nix? => return []
    if :valtype(routes) != "array" => return []

    return routes
xx

act lookup_href_by_slug(ctx, portal, slug)
    if portal.nix? or portal == "" => return ""
    if slug.nix? or slug == ""     => return ""

    routes | load_routes_for_portal(ctx, portal)
    if :valtype(routes) != "array" => return ""

    for meta in routes
        if meta.nix? => skip
        if meta["slug"] == slug
            href_abs | meta["href"]
            if !href_abs.nix? and ("" + href_abs) != ""
                return "" + href_abs
            xx
        xx
    xx

    return ""
xx

act lookup_slug_by_href(ctx, portal, href_abs)
    if portal.nix? or portal == "" => return ""
    if href_abs.nix? or href_abs == "" => return ""

    routes | load_routes_for_portal(ctx, portal)
    if :valtype(routes) != "array" => return ""

    for meta in routes
        if meta.nix? => skip
        if ("" + meta["href"]) == ("" + href_abs)
            s | meta["slug"]
            if !s.nix? and ("" + s) != ""
                return "" + s
            xx
        xx
    xx

    return ""
xx

/// ======================================================================
/// CODE STASH (PREVENT TOKEN/WIKILINK PROCESSING INSIDE CODE/PRE)
/// ======================================================================

act stash_code_segments(html)
    if html.nix? => return {"html": "", "stash": []}

    out   | "" + html
    stash | []
    n     | 0

    /// Stash fenced blocks first (<pre ... </pre>)
    sweep out
        "<pre" ... "</pre>":
            seg | "" + self
            key | "@@TB_CODE_{n}@@"
            :put_last!(stash, {"k": key, "v": seg})
            :update_where!(out, seg, key)
            n += 1
    xx

    /// Then stash inline code (<code ... </code>)
    sweep out
        "<code" ... "</code>":
            seg | "" + self
            key | "@@TB_CODE_{n}@@"
            :put_last!(stash, {"k": key, "v": seg})
            :update_where!(out, seg, key)
            n += 1
    xx

    return {"html": out, "stash": stash}
xx

act restore_code_segments(html, stash)
    if html.nix? => return ""
    out | "" + html
    if stash.nix? => return out
    if :valtype(stash) != "array" => return out

    for item in stash
        if item.nix? => skip
        k | item["k"]
        v | item["v"]
        if k.nix? or v.nix? => skip
        :update_where!(out, "" + k, "" + v)
    xx

    return out
xx

/// ======================================================================
/// 4) MISSING PAGE ROUTING (NO FALLBACKS, NO "#")
/// ======================================================================

/// Missing-page links point to one real explainer page:
///   content/docs/missing.md -> /docs/missing.html
/// Mount-aware: respects routing.dist_root via portal_mount().
act missing_page_href()
    return "/docs/missing.html"
xx

/// ======================================================================
/// 5) HTML SAFETY + FINAL <a>
/// ======================================================================

act escape_attr(s)
    if s.nix? => return ""
    out | "" + s
    :update_where!(out, "\"", "&quot;")
    return out
xx

act escape_text(s)
    if s.nix? => return ""
    out | "" + s
    :update_where!(out, "&", "&amp;")
    :update_where!(out, "<", "&lt;")
    :update_where!(out, ">", "&gt;")
    return out
xx

/// Small helper to build the final <a> tag.
/// CRITICAL:
/// - NEVER emits href="#".
/// - If href is empty, it ALWAYS routes to /docs/missing.html.
act build_wikilink_html(href, label, is_external, klass)
    href_s  | "" + href
    label_s | "" + label
    klass_s | "" + klass

    /// Auto-mark missing pages (single source of truth)
    if href_s == "/docs/missing.html"
        klass_s |= " sheriff-missing-link"
    xx

    if href_s.nix? or href_s == ""
        :update!(href_s, missing_page_href())
    xx

    if label_s.nix? or label_s == ""
        :update!(label_s, href_s)
    xx

    if klass_s.nix? or klass_s == ""
        :update!(klass_s, "sheriff-link")
    xx

    /// Auto-mark missing-page links (mount-safe)
    /// Matches both:
    ///   /docs/missing.html
    ///   /<mount>/docs/missing.html
    if :ends_with(href_s, "/docs/missing.html")
        /// append (don't replace)
        :update!(klass_s, "{klass_s} sheriff-missing-link")
    xx

    href_s  |= escape_attr(href_s)
    label_s |= escape_text(label_s)
    klass_s |= escape_attr(klass_s)

    html_parts | []
    :put_last!(html_parts, "<a href=\"")
    :put_last!(html_parts, href_s)
    :put_last!(html_parts, "\" class=\"")
    :put_last!(html_parts, klass_s)
    :put_last!(html_parts, "\">")
    :put_last!(html_parts, label_s)

    if is_external
        :put_last!(html_parts, "<span class=\"external-link-icon\" aria-hidden=\"true\"></span>")
    xx

    :put_last!(html_parts, "</a>")
    return :pack(html_parts)
xx

/// ======================================================================
/// 6) RESOLVE A SINGLE WIKILINK
/// ======================================================================

act resolve_wikilink(inner, ctx, portal)
    if inner.nix? => return ""

    raw | :trim(inner)
    if raw == "" => return ""

    core | :keep_between(raw, "[[", "]]")
    if core.nix? or core == ""
        core |= raw
    xx

    inner_text | :trim(core)
    if inner_text == "" => return ""

    /// IMAGE WIKILINK (fixed shape)
    if :starts_with(inner_text, "image:")
        body | :keep_after(inner_text, "image:")
        if body.nix? => return ""

        parts | :split(body, "|")
        if parts.nix? => return ""

        filename | parts[0]
        size     | parts[1]
        align    | parts[2]
        caption  | parts[3]

        if filename.nix? or filename == "" => return ""

        if size.nix? or size == ""   => size   | "full"
        if align.nix? or align == "" => align  | "center"
        if caption.nix?              => caption | ""

        /// mount-aware src
        m | portal_mount(portal)
        src | "/public/images/{filename}"
        if m != ""
            src | "{m}/public/images/{filename}"
        xx

        src_e | escape_attr(src)
        cap_a | escape_attr(caption)
        cap_t | escape_text(caption)

        img_class | "sheriff-image sheriff-image-{size} sheriff-align-{align}"

        parts_out | []
        :put_last!(parts_out, "<span class=\"sheriff-image-block\">")
        :put_last!(parts_out, "<img src=\"")
        :put_last!(parts_out, src_e)
        :put_last!(parts_out, "\" alt=\"")
        :put_last!(parts_out, cap_a)
        :put_last!(parts_out, "\" class=\"")
        :put_last!(parts_out, img_class)
        :put_last!(parts_out, "\">")
        :put_last!(parts_out, "<span class=\"sheriff-image-caption\">")
        :put_last!(parts_out, cap_t)
        :put_last!(parts_out, "</span>")
        :put_last!(parts_out, "</span>")

        return :pack(parts_out)
    xx

    /// ======================================================================
    /// FOCUS PANEL (STRICT SHAPE)
    /// ======================================================================
    /// REQUIRED:
    /// [[focuspanel:filename.png|size|align|caption]]
    if :starts_with(inner_text, "focuspanel:")
        body | :keep_after(inner_text, "focuspanel:")
        if body.nix? => return ""

        parts | :split(body, "|")
        if parts.nix? => return ""

        /// STRICT: must be exactly 4 segments
        if parts.len < 4
            return ""
        xx

        filename | parts[0]
        size     | parts[1]
        align    | parts[2]
        caption  | parts[3]

        if filename.nix? or filename == "" => return ""
        if size.nix? or size == ""         => return ""
        if align.nix? or align == ""       => return ""
        if caption.nix?                    => caption | ""

        /// mount-aware src
        m | portal_mount(portal)
        src | "/public/images/{filename}"
        if m != ""
            src | "{m}/public/images/{filename}"
        xx

        src_e | escape_attr(src)
        cap_a | escape_attr(caption)
        cap_t | escape_text(caption)

        out | []
        :put_last!(out, "<div class=\"sheriff-focus-panel\" data-focus-panel data-default-src=\"")
        :put_last!(out, src_e)
        :put_last!(out, "\" data-default-caption=\"")
        :put_last!(out, cap_a)
        :put_last!(out, "\">")

        :put_last!(out, "<img class=\"sheriff-focus-panel-img\" src=\"")
        :put_last!(out, src_e)
        :put_last!(out, "\" alt=\"")
        :put_last!(out, cap_a)
        :put_last!(out, "\">")

        :put_last!(out, "<div class=\"sheriff-focus-panel-caption\">")
        :put_last!(out, cap_t)
        :put_last!(out, "</div>")

        :put_last!(out, "</div>")

        return :pack(out)
    xx

    /// FOCUS LINK (drives the focus panel on hover)
    /// [[focus:image:filename.png|Label]]
    if :starts_with(inner_text, "focus:")
        rest | :keep_after(inner_text, "focus:")
        if rest.nix? or rest == "" => return ""

        parts | :split(rest, "|")
        if parts.nix? => return ""
        if parts.len < 2 => return ""

        img_ref | parts[0]
        label   | parts[1]

        if img_ref.nix? or img_ref == "" => return ""
        if label.nix? => label | ""

        if :starts_with(img_ref, "image:") == false
            return ""
        xx

        filename | :keep_after(img_ref, "image:")
        if filename.nix? or filename == "" => return ""

        /// mount-aware src
        m | portal_mount(portal)
        src | "/public/images/{filename}"
        if m != ""
            src | "{m}/public/images/{filename}"
        xx

        src_e   | escape_attr(src)
        cap_a   | escape_attr(label)
        label_t | escape_text(label)

        out | []
        :put_last!(out, "<span class=\"sheriff-link sheriff-focus-link\" data-focus-src=\"")
        :put_last!(out, src_e)
        :put_last!(out, "\" data-focus-caption=\"")
        :put_last!(out, cap_a)
        :put_last!(out, "\" tabindex=\"0\" role=\"link\">")
        :put_last!(out, label_t)
        :put_last!(out, "</span>")
        return :pack(out)
    xx

    /// ======================================================
    /// WIKILINK LOGIC (STRICT: routes.json OR missing page)
    /// ======================================================

    link_part  | :keep_before(inner_text, "|")
    label_part | :keep_after(inner_text, "|")

    if link_part.nix? or link_part == ""
        link_part |= inner_text
    xx

    link_part  |= :trim(link_part)
    label_part |= :trim(label_part)

    display_label | label_part
    if display_label.nix? or display_label == ""
        display_label |= link_part
    xx

    lower_link  | :lower(link_part)
    is_external | :starts_with(lower_link, "http://") or :starts_with(lower_link, "https://")
    is_portal   | :starts_with(link_part, "p/")
    is_user     | :starts_with(link_part, "u/")

    judge
        is_external:
            return build_wikilink_html(link_part, display_label, true, "sheriff-link")

        is_portal:
            portal_name | :keep_between(link_part, "p/", "/")
            rest        | :keep_after(link_part, "p/{portal_name}/")

            if portal_name.nix? or portal_name == "" or rest.nix? or rest == ""
                return build_wikilink_html(missing_page_href(), display_label, false, "sheriff-link sheriff-missing-link")
            xx

            parts  | split_anchor(rest)
            page   | parts["page"]
            anchor | parts["anchor"]

            slug | normalize_to_slug(page)

            href  | lookup_href_by_slug(ctx, portal_name, slug)
            klass | "sheriff-link"

            /// STRICT: if not found, go to THIS ONE missing page (no portal mounts, no portal_name)
            if href == ""
                href  |= missing_page_href()
                klass |= " sheriff-missing-link"
            xx

            if anchor != ""
                href |= "{href}#{anchor}"
            xx

            return build_wikilink_html(href, display_label, false, klass)

        is_user:
            username | :keep_after(link_part, "u/")
            if username.nix? or username == ""
                return build_wikilink_html(portal, "", display_label, false, "sheriff-link sheriff-missing-link")
            xx
            return build_wikilink_html(portal, "/users/{username}", display_label, false, "sheriff-link")

        else:
            parts  | split_anchor(link_part)
            page   | parts["page"]
            anchor | parts["anchor"]

            slug | normalize_to_slug(page)

            href  | lookup_href_by_slug(ctx, portal, slug)
            klass | "sheriff-link"

            if href == ""
                href  |= missing_page_href()
                klass |= " sheriff-missing-link"
            xx

            /// ONLY append anchor if non-empty
            if anchor != ""
                href |= "{href}#{anchor}"
            xx

            return build_wikilink_html(href, display_label, false, klass)
    xx
xx

/// ======================================================================
/// 7) PROCESS ALL WIKILINKS IN A PAGE
/// ======================================================================

act process_wikilinks(ctx)
    body   | ctx["body"]
    portal | ctx["portal"]

    if body.nix?   => return ctx
    if portal.nix? => return ctx

    /// --- STASH CODE/PRE so we don't mutate code examples ---
    stashed | stash_code_segments(body)
    work    | stashed["html"]
    stash   | stashed["stash"]

    result | "" + work
    focus_html | ""

    sweep work
        "[[" ... "]]":
            if self.nix? or self == "" => skip

            core | :keep_between(self, "[[", "]]")
            core |= :trim(core)

            if :starts_with(core, "focuspanel:")
                if focus_html == ""
                    html_raw | resolve_wikilink(self, ctx, portal)
                    if !html_raw.nix? and ("" + html_raw) != ""
                        :update!(focus_html, "" + html_raw)
                    xx
                xx

                :update_where!(result, self, "")
                skip
            xx

            repl_raw | resolve_wikilink(self, ctx, portal)
            if repl_raw.nix? => skip

            repl | "" + repl_raw
            if repl == "" => skip

            :update_where!(result, self, repl)
    xx

    /// Replace SITE token AFTER wikilinks â€” still safe because code is stashed.
    :update_where!(result, "{{{SITE::FOCUS_PANEL}}}", focus_html)
    :update_where!(result, "{{{TRAILBOSS::FOCUS_PANEL}}}", focus_html)

    /// --- RESTORE CODE/PRE blocks ---
    final | restore_code_segments(result, stash)

    :update!(ctx["body"], final)
    return ctx
xx

/// ======================================================================
/// 8) PUBLISH CANONICAL WIKILINK FOR CURRENT PAGE
/// ======================================================================

act publish_canonical_link(ctx)
    portal | ctx["portal"]
    src    | ctx["path"]
    body   | ctx["body"]

    if portal.nix? => return ctx
    if src.nix?    => return ctx
    if body.nix?   => return ctx

    src_norm | "" + src
    :update_where!(src_norm, "\\", "/")

    /// WORKING SLUG DERIVATION (the one you already had)
    stem_name | :stem(src_norm)
    slug      | normalize_to_slug(stem_name)

    canonical | "[[{slug}]]"

    html | """
    <div class="sheriff-canon-wrap">
      <span class="sheriff-canon-text">{canonical}</span>
      <button
        class="copy-wikilink"
        type="button"
        data-wikilink="{canonical}"
        aria-label="Copy canonical wikilink">
        <svg
          class="copy-wikilink-icon"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          aria-hidden="true">
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
          <path d="M5 15H4a 2 2 0 0 1-2-2V4a 2 2 0 0 1 2-2h9a 2 2 0 0 1 2 2v1"/>
        </svg>
      </button>
    </div>
    """

    updated | "" + body
    :update_where!(updated, "{{{TRAILBOSS::CANONLINK}}}", html)
    :update!(ctx["body"], updated)

    return ctx
xx
