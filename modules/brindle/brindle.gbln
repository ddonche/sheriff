/// Brindle — auto-discover themes, register tokens, no building
act basename(p)
    parts = split(p, "/")
    if parts.len == 0
        return p
    end
    return parts[parts.len - 1]
end

act strip_css_ext(filename)
    if filename.len >= 4
        tail = filename[filename.len - 4:filename.len].lower
        if tail == ".css"
            return filename[0:filename.len - 4]
        end
    end
    return filename
end

/// Read desired theme name from goblin.yaml (or return nil if none)
act selected_theme_from_config()
    if file_exists("goblin.yaml") == false
        return nil
    end
    cfg_text = read_text("goblin.yaml")
    sanitized = yaml_sanitize(cfg_text)
    cfg = yaml_parse(sanitized)
    
    if cfg == nil
        return nil
    end
    br = cfg["brindle"]
    if br == nil
        return nil
    end
    t = br["theme"]
    if t == nil
        return nil
    end
    trimmed = ("" + t).trim
    if trimmed == ""
        return nil
    end
    return trimmed
end

/// Brindle — build_css_files (no safety rails, assumes required files exist)
act build_css_files()
    /// Always ensure destination directories exist
    create_dir!("dist/modules/brindle/themes")

    /// Copy baseline.css unconditionally
    baseline_src  = "modules/brindle/baseline.css"
    baseline_dest = "dist/modules/brindle/baseline.css"
    baseline_content = read_text(baseline_src)
    write_text!(baseline_dest, baseline_content)
    say "Brindle: copied baseline.css"

    /// Copy all theme files from /modules/brindle/themes → /dist/modules/brindle/themes
    theme_files = walk("modules/brindle/themes", "**/*.css")
    for theme_file in theme_files
        normalized   = path_normalize(theme_file)
        parts        = split(normalized, "/")
        filename     = parts[parts.len - 1]
        output_path  = "dist/modules/brindle/themes/" + filename

        theme_content = read_text(theme_file)
        write_text!(output_path, theme_content)
        say "Brindle: copied " + filename
    end
end

act publish_syntax_tokens()
    head_html = raw '''
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
'''

    foot_html = raw '''
<script>
  document.addEventListener('DOMContentLoaded', function () {
    if (!window.hljs) return;

    // 1) Register Goblin language
    function goblin(hljs) {
      const LINE   = hljs.COMMENT('///', '$');
      const MULTI  = { className: 'comment', begin: /\/\/\/\//, end: /\/\/\/\//, dotAll: true, greedy: true };
      const INLINE = { className: 'comment', begin: /<----.*$/ };

      const LITERALS = { literal: 'true false nil Unit' };

      const INTERP = { className: 'subst', begin: /\{[A-Za-z_][A-Za-z0-9_]*\}/ };
      const STRING = {
        className: 'string',
        variants: [
          { begin: /"/, end: /"/, contains: [INTERP] },
          { begin: /raw\s+"/, end: /"/, contains: [INTERP] },
          { begin: /"""/, end: /"""/, contains: [INTERP] }
        ]
      };

      const HEX  = { className: 'number', begin: /\b0x[0-9A-Fa-f_]+\b/ };
      const BIN  = { className: 'number', begin: /\b0b[01_]+\b/ };
      const SCI  = { className: 'number', begin: /\b\d(?:[\d_]*\d)?(?:\.\d(?:[\d_]*\d)?)?(?:[eE][+-]?\d+)?\b/ };
      const DICE = { className: 'number', begin: /\b\d+d\d+(?:[+-]\d+)?\b/ };

      const OPERATORS = {
        className: 'operator',
        begin: /(>>>|>>|::|===|!===|!==|==|<=|>=|\.{3}|\.{2}|%s|%o|\+\+|--|\*\*=?|\/\/|=>|\+=|-=?|\*=|\/=|%=|<>\b|\?>|&&|\?\?|[+\-*\/%_^@#=<!>&|><])/
      };
      const RANGE = { className: 'operator', begin: /\.{2,3}/ };

      const ACTION_DEF = {
        className: 'function',
        begin: /\b(?:act|action)\s+[A-Za-z_][A-Za-z0-9_]*/,
        returnBegin: true,
        contains: [
          { className: 'keyword', begin: /\b(?:act|action)\b/ },
          { className: 'title',   begin: /[A-Za-z_][A-Za-z0-9_]*/ }
        ]
      };
      const MODULE_CALL = { className: 'title',    begin: /\b[A-Za-z_][A-Za-z0-9_]*::[A-Za-z_][A-Za-z0-9_]*/ };
      const BANG_CALL   = { className: 'built_in', begin: /\b[A-Za-z_][A-Za-z0-9_]*!/ };
      const PROPERTY    = { className: 'operator', begin: />>/ };
      const TRIPLE_BRACE= { className: 'subst',    begin: /\{\{\{/, end: /\}\}\}/ };

      const KEYWORDS = {
        keyword:
          'if elif else for in while repeat unless ' +
          'attempt rescue ensure raise say warn error ' +
          'return skip jump until stop assert ' +
          'act action enum use import export via test ' +
          'contract prefer ' +
          'judge judge_all using morph vault banish unbanish expose ' +
          'pick roll roll_detail reap map ' +
          'nc self set burn show_ids as of ' +
          'end blob',
        literal: LITERALS.literal
      };

      return {
        name: 'Goblin',
        aliases: ['gbln','gob'],
        keywords: KEYWORDS,
        contains: [
          MULTI, LINE, INLINE,
          ACTION_DEF, MODULE_CALL, BANG_CALL,
          TRIPLE_BRACE, PROPERTY, OPERATORS, RANGE,
          STRING, HEX, BIN, DICE, SCI
        ]
      };
    }

    window.hljs.registerLanguage('goblin', goblin);

    // Optional sanity check
    if (window.hljs.getLanguage('goblin')) {
      console.log('Goblin language registered.');
    } else {
      console.warn('Failed to register Goblin language.');
    }

    // 2) Map <pre lang="xyz"> → language-xyz
    var pres = document.querySelectorAll('pre[lang]');
    for (var i = 0; i < pres.length; i++) {
      var pre  = pres[i];
      var lang = (pre.getAttribute('lang') || '').trim().toLowerCase();
      if (!lang) continue;

      var code = pre.querySelector('code');
      if (!code) {
        code = document.createElement('code');
        code.textContent = pre.textContent;
        pre.textContent  = '';
        pre.appendChild(code);
      }
      pre.classList.add('language-' + lang);
      code.classList.add('language-' + lang);
    }

    // 3) Highlight everything
    window.hljs.highlightAll();
  });
</script>
'''

    register_token("BRINDLE", "HIGHLIGHT_HEAD", head_html)
    register_token("BRINDLE", "HIGHLIGHT_FOOT", foot_html)
    return Unit
end

/// Register BRINDLE::<THEME> for every file in modules/brindle/themes/*.css
act publish_theme_tokens()
    theme_dir = "modules/brindle/themes"
    if file_exists(theme_dir) == false
        return 0
    end

    files = walk(theme_dir, "**/*.css")
    file_count = 0

    for f in files
        base = basename(f)               /// e.g., "obsidian.css"
        stem = strip_css_ext(base)       /// e.g., "obsidian"
        if ("" + stem).trim == ""
            skip
        end
        token = upper(stem)              /// "OBSIDIAN"
        href  = "/modules/brindle/themes/" + stem + ".css"
        register_token("BRINDLE", token, href)
        file_count = file_count + 1
    end

    return file_count
end

/// Publish static tokens (BASELINE + all themes) and wire BRINDLE::CSS
act publish_tokens()
    baseline_href = "/modules/brindle/baseline.css"
    
    if file_exists("modules/brindle/baseline.css") == false
        register_token("BRINDLE", "CSS", "<!-- ERROR: baseline.css not found -->")
    else
        publish_theme_tokens()
        publish_brand_tokens()
        publish_syntax_tokens()
        
        chosen = selected_theme_from_config()
        
        if chosen !== nil
            chosen_lo = lower(chosen.trim)
            chosen_fs = "modules/brindle/themes/" + chosen_lo + ".css"
            
            if file_exists(chosen_fs)
                theme_href = "/modules/brindle/themes/" + chosen_lo + ".css"
                /// baseline FIRST, theme LAST so theme wins
                css_links = "<link rel=\"stylesheet\" href=\"" + baseline_href + "\">\n    <link rel=\"stylesheet\" href=\"" + theme_href + "\">"
                register_token("BRINDLE", "CSS", css_links)
            else
                css_links = "<link rel=\"stylesheet\" href=\"" + baseline_href + "\">"
                register_token("BRINDLE", "CSS", css_links)
            end
        else
            css_links = "<link rel=\"stylesheet\" href=\"" + baseline_href + "\">"
            register_token("BRINDLE", "CSS", css_links)
        end
    end
end

/// --- helpers to read config safely ----------------------------------------
act brindle_cfg()
    if file_exists("goblin.yaml") == false
        return {}
    end

    config_text     = read_text("goblin.yaml")
    sanitized_text  = yaml_sanitize(config_text)
    parsed_config   = yaml_parse(sanitized_text)
    if parsed_config == nil
        return {}
    end
    return parsed_config
end

act cfg_str(map_value, key_name, default_value)
    if map_value == nil or valtype(map_value) !== "map"
        return default_value
    end

    raw_value = map_value[key_name]
    if raw_value == nil
        return default_value
    end

    string_value = ("" + raw_value).trim
    if string_value == ""
        return default_value
    end
    return string_value
end

/// --- publish brand tokens (root-absolute paths) ---------------------------
/// goblin.yaml:
/// brindle:
///   brand_name: "Goblin"
///   logo: "/public/logo.svg"     # optional override
///   favicon: "/public/favicon.ico"
act publish_brand_tokens()
    config_map      = brindle_cfg()
    brindle_section = config_map["brindle"]

    brand_name = cfg_str(brindle_section, "brand_name", "Site")
    brand_logo = cfg_str(brindle_section, "logo", "Logo")
    brand_favicon = cfg_str(brindle_section, "favicon", "Favicon")

    /// Hard paths, root-absolute so they work from any depth
    register_token("BRINDLE", "FAVICON",   "/public/{brand_favicon}")
    register_token("BRINDLE", "BRAND_NAME", brand_name)
    register_token("BRINDLE", "LOGO_SRC",  "/public/{brand_logo}")
    register_token("BRINDLE", "BRAND_ALT", brand_name)

    /// Composite <img> tag (root-absolute src)
    register_token(
        "BRINDLE",
        "LOGO_IMG",
        "<img class=\"brand-logo\" src=\"/public/{brand_logo}\" alt=\"" + brand_name + "\" />"
    )

    return Unit
end